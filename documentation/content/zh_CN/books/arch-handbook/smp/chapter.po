# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR The FreeBSD Project
# This file is distributed under the same license as the FreeBSD Documentation package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: FreeBSD Documentation VERSION\n"
"POT-Creation-Date: 2021-02-21 18:54-0300\n"
"PO-Revision-Date: 2021-04-05 01:29+0000\n"
"Last-Translator: Anonymous <noreply@weblate.org>\n"
"Language-Team: Chinese (Simplified) <https://translate-dev.freebsd.org/"
"projects/documentation/booksarch-handbooksmpchapter/zh_CN/>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Weblate 4.5.2\n"

#. type: YAML Front Matter: title
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:1
#, no-wrap
msgid "Chapter 8. SMPng Design Document"
msgstr ""

#. type: Title =
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:8
#, no-wrap
msgid "SMPng Design Document"
msgstr "SMPng 设计文档"

#. type: Title ==
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:33
#, no-wrap
msgid "Introduction"
msgstr "介绍"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:36
msgid ""
"This document presents the current design and implementation of the SMPng "
"Architecture. First, the basic primitives and tools are introduced. Next, a "
"general architecture for the FreeBSD kernel's synchronization and execution "
"model is laid out. Then, locking strategies for specific subsystems are "
"discussed, documenting the approaches taken to introduce fine-grained "
"synchronization and parallelism for each subsystem. Finally, detailed "
"implementation notes are provided to motivate design choices, and make the "
"reader aware of important implications involving the use of specific "
"primitives."
msgstr ""
"这份文档对目前 SMPng 架构的设计与实现进行了介绍。它首先介绍了基本的原语和相关工具， 其后是关于FreeBSD 内核的同步与执行模型， "
"接下来讨论了具体系统中的锁策略，并描述了在各个子系统中引入细粒度的同步和实现并行化的步骤，最后是详细的实现说明， "
"用以解释最初做出某些设计决策的动机，并使读者了解使用特定的原语所可能产生的重大影响。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:38
msgid ""
"This document is a work-in-progress, and will be updated to reflect on-going "
"design and implementation activities associated with the SMPng Project. Many "
"sections currently exist only in outline form, but will be fleshed out as "
"work proceeds. Updates or suggestions regarding the document may be directed "
"to the document editors."
msgstr ""
"这份文档仍在撰写当中， 并将不断更新以反映与 SMPng项目有关的最新设计与实现的情况。 其中有许多小节目前还只是提纲，但我们会逐渐为其充实内容。 "
"关于这份文档的更新和建议，请发给文档编辑。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:40
msgid ""
"The goal of SMPng is to allow concurrency in the kernel. The kernel is "
"basically one rather large and complex program. To make the kernel "
"multi-threaded we use some of the same tools used to make other programs "
"multi-threaded. These include mutexes, shared/exclusive locks, semaphores, "
"and condition variables. For the definitions of these and other SMP-related "
"terms, please see the <<smp-glossary>> section of this article."
msgstr ""

#. type: Title ==
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:42
#, no-wrap
msgid "Basic Tools and Locking Fundamentals"
msgstr "基本工具与上锁的基础知识"

#. type: Title ===
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:44
#, no-wrap
msgid "Atomic Instructions and Memory Barriers"
msgstr "原子操作指令和内存栅"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:47
msgid ""
"There are several existing treatments of memory barriers and atomic "
"instructions, so this section will not include a lot of detail. To put it "
"simply, one can not go around reading variables without a lock if a lock is "
"used to protect writes to that variable. This becomes obvious when you "
"consider that memory barriers simply determine relative order of memory "
"operations; they do not make any guarantee about timing of memory "
"operations. That is, a memory barrier does not force the contents of a CPU's "
"local cache or store buffer to flush. Instead, the memory barrier at lock "
"release simply ensures that all writes to the protected data will be visible "
"to other CPU's or devices if the write to release the lock is visible. The "
"CPU is free to keep that data in its cache or store buffer as long as it "
"wants. However, if another CPU performs an atomic instruction on the same "
"datum, the first CPU must guarantee that the updated value is made visible "
"to the second CPU along with any other operations that memory barriers may "
"require."
msgstr ""
"关于内存栅和原子操作指令已经有很多介绍材料，因此这一节并不打算对其进行详尽的介绍。 简而言之， "
"如果有对某一变量上写锁，就不能在不获得相应的锁时对其进行读取操作。 也就是说，内存栅的作用在于保证内存操作的相对顺序， "
"但并不保证内存操作的严格时序。换言之， 内存栅并不保证 CPU 将本地快取缓存或存储缓冲的内容刷写回内存，而是在锁释放时确保其所保护的数据， "
"对于能看到刚释放的那个锁的 CPU或设备可见。 持有内存栅的 CPU可以在其快取缓存或存储缓冲中将数据保持其所希望的、 任意长的时间，但如果其它 CPU "
"在同一数据元上执行原子操作， 则第一个 CPU 必须保证，其所更新的数据值， 以及内存栅所要求的任何其它操作， 对第二个 CPU 可见。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:49
msgid ""
"For example, assuming a simple model where data is considered visible when "
"it is in main memory (or a global cache), when an atomic instruction is "
"triggered on one CPU, other CPU's store buffers and caches must flush any "
"writes to that same cache line along with any pending operations behind a "
"memory barrier."
msgstr ""
"例如， 假设在一简单模型中， 认为在主存 (或某一全局快取缓存)中的数据是可见的， 当某一 CPU 上触发原子操作时， 其它 "
"CPU的存储缓冲和快取缓存就必须对同一快取缓存线上的全部写操作，以及内存栅之后的全部未完成操作进行刷写。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:51
msgid ""
"This requires one to take special care when using an item protected by "
"atomic instructions. For example, in the sleep mutex implementation, we have "
"to use an `atomic_cmpset` rather than an `atomic_set` to turn on the "
"`MTX_CONTESTED` bit. The reason is that we read the value of `mtx_lock` into "
"a variable and then make a decision based on that read. However, the value "
"we read may be stale, or it may change while we are making our "
"decision. Thus, when the `atomic_set` executed, it may end up setting the "
"bit on another value than the one we made the decision on. Thus, we have to "
"use an `atomic_cmpset` to set the value only if the value we made the "
"decision on is up-to-date and valid."
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:53
msgid ""
"Finally, atomic instructions only allow one item to be updated or read. If "
"one needs to atomically update several items, then a lock must be used "
"instead. For example, if two counters must be read and have values that are "
"consistent relative to each other, then those counters must be protected by "
"a lock rather than by separate atomic instructions."
msgstr ""
"最后， 原子操作只允许一次更新或读一个内存单元。需要原子地更新多个单元时， 就必须使用锁来代替它了。例如， "
"如果需要更新两个相互关联的计数器时，就必须使用锁， 而不是两次单独的原子操作了。"

#. type: Title ===
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:54
#, no-wrap
msgid "Read Locks Versus Write Locks"
msgstr "读锁与写锁"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:57
msgid ""
"Read locks do not need to be as strong as write locks. Both types of locks "
"need to ensure that the data they are accessing is not stale. However, only "
"write access requires exclusive access. Multiple threads can safely read a "
"value. Using different types of locks for reads and writes can be "
"implemented in a number of ways."
msgstr ""
"读锁并不需要像写锁那样强。 这两种类型的锁，都需要确保通过它们访问的不是过时的数据。 然而，只有写操作必须是排他的， "
"而多个线程则可以安全地读同一变量的值。使用不同类型的锁用于读和写操作有许多各自不同的实现方式。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:59
msgid ""
"First, sx locks can be used in this manner by using an exclusive lock when "
"writing and a shared lock when reading. This method is quite "
"straightforward."
msgstr "第一种方法是用 sx 锁， 它可以用于实现写时使用的排他锁，而读时则作为共享锁。 这种方法十分简单明了。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:61
msgid ""
"A second method is a bit more obscure. You can protect a datum with multiple "
"locks. Then for reading that data you simply need to have a read lock of one "
"of the locks. However, to write to the data, you need to have a write lock "
"of all of the locks. This can make writing rather expensive but can be "
"useful when data is accessed in various ways. For example, the parent "
"process pointer is protected by both the `proctree_lock` sx lock and the "
"per-process mutex. Sometimes the proc lock is easier as we are just checking "
"to see who a parent of a process is that we already have locked. However, "
"other places such as `inferior` need to walk the tree of processes via "
"parent pointers and locking each process would be prohibitive as well as a "
"pain to guarantee that the condition you are checking remains valid for both "
"the check and the actions taken as a result of the check."
msgstr ""

#. type: Title ===
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:62
#, no-wrap
msgid "Locking Conditions and Results"
msgstr "上锁状态和结果"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:65
msgid ""
"If you need a lock to check the state of a variable so that you can take an "
"action based on the state you read, you can not just hold the lock while "
"reading the variable and then drop the lock before you act on the value you "
"read. Once you drop the lock, the variable can change rendering your "
"decision invalid. Thus, you must hold the lock both while reading the "
"variable and while performing the action as a result of the test."
msgstr ""
"如果您需要使用锁来保持所检查变量的状态， 并据此执行某些操作时，是不能仅仅在读变量之前对其上锁， 并在执行操作之前解锁的。过早解锁将使变量再次可变， "
"这可能会导致之前所做的决策失效。因此， 在所做检测引发的动作结束之前， 必须继续保持上锁状态。"

#. type: Title ==
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:67
#, no-wrap
msgid "General Architecture and Design"
msgstr "架构与设计概览"

#. type: Title ===
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:69
#, no-wrap
msgid "Interrupt Handling"
msgstr "对中断的处理"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:72
msgid ""
"Following the pattern of several other multi-threaded UNIX(R) kernels, "
"FreeBSD deals with interrupt handlers by giving them their own thread "
"context. Providing a context for interrupt handlers allows them to block on "
"locks. To help avoid latency, however, interrupt threads run at real-time "
"kernel priority. Thus, interrupt handlers should not execute for very long "
"to avoid starving other kernel threads. In addition, since multiple handlers "
"may share an interrupt thread, interrupt handlers should not sleep or use a "
"sleepable lock to avoid starving another interrupt handler."
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:74
msgid ""
"The interrupt threads currently in FreeBSD are referred to as heavyweight "
"interrupt threads. They are called this because switching to an interrupt "
"thread involves a full context switch. In the initial implementation, the "
"kernel was not preemptive and thus interrupts that interrupted a kernel "
"thread would have to wait until the kernel thread blocked or returned to "
"userland before they would have an opportunity to run."
msgstr ""
"目前在 FreeBSD 中的中断线程是指重量级中断线程。这样称呼它们的原因在于， 转到中断线程需要执行一次完整的上下文切换操作。在最初的实现中， "
"内核不允许抢占， 因此中断在打断内核线程之前，必须等待内核线程阻塞或返回用户态之后才能执行。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:76
msgid ""
"To deal with the latency problems, the kernel in FreeBSD has been made "
"preemptive. Currently, we only preempt a kernel thread when we release a "
"sleep mutex or when an interrupt comes in. However, the plan is to make the "
"FreeBSD kernel fully preemptive as described below."
msgstr ""
"为了解决响应时间问题， FreeBSD 内核现在采用了抢占式调度策略。目前， 只有释放休眠 mutex 或发生中断时才能抢断内核线程，但最终目标是在 "
"FreeBSD 上实现下面所描述的全抢占式调度策略。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:78
msgid ""
"Not all interrupt handlers execute in a thread context. Instead, some "
"handlers execute directly in primary interrupt context. These interrupt "
"handlers are currently misnamed \"fast\" interrupt handlers since the "
"`INTR_FAST` flag used in earlier versions of the kernel is used to mark "
"these handlers. The only interrupts which currently use these types of "
"interrupt handlers are clock interrupts and serial I/O device "
"interrupts. Since these handlers do not have their own context, they may not "
"acquire blocking locks and thus may only use spin mutexes."
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:80
msgid ""
"Finally, there is one optional optimization that can be added in MD code "
"called lightweight context switches. Since an interrupt thread executes in a "
"kernel context, it can borrow the vmspace of any process. Thus, in a "
"lightweight context switch, the switch to the interrupt thread does not "
"switch vmspaces but borrows the vmspace of the interrupted thread. In order "
"to ensure that the vmspace of the interrupted thread does not disappear out "
"from under us, the interrupted thread is not allowed to execute until the "
"interrupt thread is no longer borrowing its vmspace. This can happen when "
"the interrupt thread either blocks or finishes. If an interrupt thread "
"blocks, then it will use its own context when it is made runnable "
"again. Thus, it can release the interrupted thread."
msgstr ""
"最后， 还有一种称为轻量级上下文切换的优化，可以在 MD 代码中使用。 因为中断线程都是在内核上下文中执行的，所以它可以借用任意进程的 vmspace "
"(虚拟内存地址空间)。 因此，在轻量级上下文切换中， 切换到中断线程并不切换对应的 vmspace，而是借用被中断线程的 vmspace。 "
"为确保被中断线程的 vmspace不在中断处理过程中消失， 被中断线程在中断线程不再借用其 vmspace之前是不允许执行的。 "
"刚才提到的情况可能在中断线程阻塞或完成时发生。如果中断线程发生阻塞， 则它再次进入可运行状态时将使用自己的上下文，这样一来， 就可以释放被中断的线程了。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:82
msgid ""
"The cons of this optimization are that they are very machine specific and "
"complex and thus only worth the effort if their is a large performance "
"improvement. At this point it is probably too early to tell, and in fact, "
"will probably hurt performance as almost all interrupt handlers will "
"immediately block on Giant and require a thread fix-up when they "
"block. Also, an alternative method of interrupt handling has been proposed "
"by Mike Smith that works like so:"
msgstr ""
"这种优化的坏处在于它们和硬件紧密相关， 而且实现比较复杂，因此只有在这样做能带来大幅性能改善时才应采用。目前这样说可能还为时过早， "
"而且事实上可能会反而导致性能下降，因为几乎所有的中断处理程序都会立即被全局锁 (Giant) 阻塞，而这种阻塞将进而需要线程修正。 另外， Mike "
"Smith提议采用另一种方式来处理中断线程："

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:84
msgid ""
"Each interrupt handler has two parts: a predicate which runs in primary "
"interrupt context and a handler which runs in its own thread context."
msgstr ""
"每个中断处理程序分为两部分， 一个在主中断上下文中运行的主体(predicate) 和一个在自己的线程上下文中执行的处理程序 (handler)。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:85
msgid ""
"If an interrupt handler has a predicate, then when an interrupt is "
"triggered, the predicate is run. If the predicate returns true then the "
"interrupt is assumed to be fully handled and the kernel returns from the "
"interrupt. If the predicate returns false or there is no predicate, then the "
"threaded handler is scheduled to run."
msgstr ""
"如果中断处理程序拥有主体， 则当触发中断时， 执行该主体。如果主体返回真， 则认为该中断被处理完毕， 内核从中断返回。如果主体返回假， 或者中断没有主体，"
" 则调度运行线程式处理程序。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:87
msgid ""
"Fitting light weight context switches into this scheme might prove rather "
"complicated. Since we may want to change to this scheme at some point in the "
"future, it is probably best to defer work on light weight context switches "
"until we have settled on the final interrupt handling architecture and "
"determined how light weight context switches might or might not fit into it."
msgstr ""
"在这一模式中适当地采用轻量级上下文切换可能是非常复杂的。因为我们可能会希望在未来改变这一模式， "
"因此现在最好的方案，应该是暂时推迟在轻量级上下文切换之上的工作，以便进一步完善中断处理架构， 随后再考察轻量级上下文切换是否适用。"

#. type: Title ===
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:88
#, no-wrap
msgid "Kernel Preemption and Critical Sections"
msgstr "内核抢占与临界区"

#. type: Title ====
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:90
#, no-wrap
msgid "Kernel Preemption in a Nutshell"
msgstr "内核抢占简介"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:93
msgid ""
"Kernel preemption is fairly simple. The basic idea is that a CPU should "
"always be doing the highest priority work available. Well, that is the ideal "
"at least. There are a couple of cases where the expense of achieving the "
"ideal is not worth being perfect."
msgstr ""
"内核抢占的概念很简单， 其基本思想是 CPU 总应执行优先级最高的工作。当然， 至少在理想情况下是这样。 有些时候，达成这一理想的代价会十分高昂， "
"以至于在这些情况下抢占会得不偿失。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:95
msgid ""
"Implementing full kernel preemption is very straightforward: when you "
"schedule a thread to be executed by putting it on a run queue, you check to "
"see if its priority is higher than the currently executing thread. If so, "
"you initiate a context switch to that thread."
msgstr ""
"实现完全的内核抢占十分简单： 在调度将要执行的线程并放入运行队列时，检查它的优先级是否高于目前正在执行的线程。 "
"如果是这样的话，执行一次上下文切换并立即开始执行该线程。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:97
msgid ""
"While locks can protect most data in the case of a preemption, not all of "
"the kernel is preemption safe. For example, if a thread holding a spin mutex "
"preempted and the new thread attempts to grab the same spin mutex, the new "
"thread may spin forever as the interrupted thread may never get a chance to "
"execute. Also, some code such as the code to assign an address space number "
"for a process during `exec` on the Alpha needs to not be preempted as it "
"supports the actual context switch code. Preemption is disabled for these "
"code sections by using a critical section."
msgstr ""

#. type: Title ====
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:98
#, no-wrap
msgid "Critical Sections"
msgstr "临界区"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:101
msgid ""
"The responsibility of the critical section API is to prevent context "
"switches inside of a critical section. With a fully preemptive kernel, every "
"`setrunqueue` of a thread other than the current thread is a preemption "
"point. One implementation is for `critical_enter` to set a per-thread flag "
"that is cleared by its counterpart. If `setrunqueue` is called with this "
"flag set, it does not preempt regardless of the priority of the new thread "
"relative to the current thread. However, since critical sections are used in "
"spin mutexes to prevent context switches and multiple spin mutexes can be "
"acquired, the critical section API must support nesting. For this reason the "
"current implementation uses a nesting count instead of a single per-thread "
"flag."
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:103
msgid ""
"In order to minimize latency, preemptions inside of a critical section are "
"deferred rather than dropped. If a thread that would normally be preempted "
"to is made runnable while the current thread is in a critical section, then "
"a per-thread flag is set to indicate that there is a pending "
"preemption. When the outermost critical section is exited, the flag is "
"checked. If the flag is set, then the current thread is preempted to allow "
"the higher priority thread to run."
msgstr ""
"为了尽可能缩短响应时间， 在临界区中的抢占被推迟，而不是直接丢弃。 如果线程应被抢断， 并被置为可运行，而当前线程处于临界区， "
"则会设置一线程私有标志，表示有一个尚未进行的抢断操作。 当最外层临界区退出时，会检查这一标志， 如果它被置位， "
"则当前线程会被抢断，以允许更高优先级的线程开始运行。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:105
msgid ""
"Interrupts pose a problem with regards to spin mutexes. If a low-level "
"interrupt handler needs a lock, it needs to not interrupt any code needing "
"that lock to avoid possible data structure corruption. Currently, providing "
"this mechanism is piggybacked onto critical section API by means of the "
"`cpu_critical_enter` and `cpu_critical_exit` functions. Currently this API "
"disables and re-enables interrupts on all of FreeBSD's current "
"platforms. This approach may not be purely optimal, but it is simple to "
"understand and simple to get right. Theoretically, this second API need only "
"be used for spin mutexes that are used in primary interrupt "
"context. However, to make the code simpler, it is used for all spin mutexes "
"and even all critical sections. It may be desirable to split out the MD API "
"from the MI API and only use it in conjunction with the MI API in the spin "
"mutex implementation. If this approach is taken, then the MD API likely "
"would need a rename to show that it is a separate API."
msgstr ""

#. type: Title ====
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:106
#, no-wrap
msgid "Design Tradeoffs"
msgstr "设计折衷"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:109
msgid ""
"As mentioned earlier, a couple of trade-offs have been made to sacrifice "
"cases where perfect preemption may not always provide the best performance."
msgstr "如前面提到的， 当完全抢占并非总能提供最佳性能时，采取了一些折衷的措施。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:111
msgid ""
"The first trade-off is that the preemption code does not take other CPUs "
"into account. Suppose we have a two CPU's A and B with the priority of A's "
"thread as 4 and the priority of B's thread as 2. If CPU B makes a thread "
"with priority 1 runnable, then in theory, we want CPU A to switch to the new "
"thread so that we will be running the two highest priority runnable "
"threads. However, the cost of determining which CPU to enforce a preemption "
"on as well as actually signaling that CPU via an IPI along with the "
"synchronization that would be required would be enormous. Thus, the current "
"code would instead force CPU B to switch to the higher priority thread. Note "
"that this still puts the system in a better position as CPU B is executing a "
"thread of priority 1 rather than a thread of priority 2."
msgstr ""
"第一处折衷是， 抢占代码并不考虑其它 CPU 的存在。假设我们有两个 CPU， A和 B， 其中 A 上线程的优先级为 4，而 B 上线程的优先级是 2。"
" 如果 CPU B 令一优先级为 1的线程进入可运行状态， 则理论上， 我们希望 CPU A 切换至这一新线程，这样就有两个优先级最高的线程在运行了。 "
"然而， 确定哪个CPU 在抢占时更合适， 并通过 IPI 向那个 CPU 发出信号，并完成相关的同步工作的代价十分高昂。 因此， 目前的代码会强制 "
"CPU B切换至更高优先级的线程。 请注意这样做仍会让系统进入更好的状态，因为 CPU B 会去执行优先级为 1 而不是 2 的那个线程。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:113
msgid ""
"The second trade-off limits immediate kernel preemption to real-time "
"priority kernel threads. In the simple case of preemption defined above, a "
"thread is always preempted immediately (or as soon as a critical section is "
"exited) if a higher priority thread is made runnable. However, many threads "
"executing in the kernel only execute in a kernel context for a short time "
"before either blocking or returning to userland. Thus, if the kernel "
"preempts these threads to run another non-realtime kernel thread, the kernel "
"may switch out the executing thread just before it is about to sleep or "
"execute. The cache on the CPU must then adjust to the new thread. When the "
"kernel returns to the preempted thread, it must refill all the cache "
"information that was lost. In addition, two extra context switches are "
"performed that could be avoided if the kernel deferred the preemption until "
"the first thread blocked or returned to userland. Thus, by default, the "
"preemption code will only preempt immediately if the higher priority thread "
"is a real-time priority thread."
msgstr ""
"第二处折衷是限制对于实时优先级的内核线程的立即抢占。在前面所定义的抢占操作的简单情形中， 低优先级总会被立即抢断(或在其退出临界区后被抢断)。 然而， "
"许多在内核中执行的线程，有很多只会执行很短的时间就会阻塞或返回用户态。 "
"因此，如果内核抢断这些线程并执行其它非实时的内核线程，则内核可能会在这些线程马上要休眠或执行完毕之前切换出去。这样一来， CPU "
"就必须调整快取缓存以配合新线程的执行。当内核返回到被抢断的线程时， 它又需要重新填充之前丢失的快取缓存信息。此外， "
"如果内核能够将对将阻塞或返回用户态的那个线程的抢断延迟到这之后的话，还能够免去两次额外的上下文切换。 因此， "
"默认情况下，只有在优先级较高的线程是实时线程时， 抢占代码才会立即执行抢断操作。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:115
msgid ""
"Turning on full kernel preemption for all kernel threads has value as a "
"debugging aid since it exposes more race conditions. It is especially useful "
"on UP systems were many races are hard to simulate otherwise. Thus, there is "
"a kernel option `FULL_PREEMPTION` to enable preemption for all kernel "
"threads that can be used for debugging purposes."
msgstr ""

#. type: Title ===
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:116
#, no-wrap
msgid "Thread Migration"
msgstr "线程迁移"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:119
msgid ""
"Simply put, a thread migrates when it moves from one CPU to another. In a "
"non-preemptive kernel this can only happen at well-defined points such as "
"when calling `msleep` or returning to userland. However, in the preemptive "
"kernel, an interrupt can force a preemption and possible migration at any "
"time. This can have negative affects on per-CPU data since with the "
"exception of `curthread` and `curpcb` the data can change whenever you "
"migrate. Since you can potentially migrate at any time this renders "
"unprotected per-CPU data access rather useless. Thus it is desirable to be "
"able to disable migration for sections of code that need per-CPU data to be "
"stable."
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:121
msgid ""
"Critical sections currently prevent migration since they do not allow "
"context switches. However, this may be too strong of a requirement to "
"enforce in some cases since a critical section also effectively blocks "
"interrupt threads on the current processor. As a result, another API has "
"been provided to allow the current thread to indicate that if it preempted "
"it should not migrate to another CPU."
msgstr ""
"目前我们采用临界区来避免迁移， 因为它们能够阻止上下文切换。但是， 这有时可能是一种过于严厉的限制，因为临界区实际上会阻止当前处理器上的中断线程。 因而，"
"提供了另一个 API， 用以指示当前进程在被抢断时，不应迁移到另一 CPU。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:123
msgid ""
"This API is known as thread pinning and is provided by the scheduler. The "
"API consists of two functions: `sched_pin` and `sched_unpin`. These "
"functions manage a per-thread nesting count `td_pinned`. A thread is pinned "
"when its nesting count is greater than zero and a thread starts off unpinned "
"with a nesting count of zero. Each scheduler implementation is required to "
"ensure that pinned threads are only executed on the CPU that they were "
"executing on when the `sched_pin` was first called. Since the nesting count "
"is only written to by the thread itself and is only read by other threads "
"when the pinned thread is not executing but while `sched_lock` is held, then "
"`td_pinned` does not need any locking. The `sched_pin` function increments "
"the nesting count and `sched_unpin` decrements the nesting count. Note that "
"these functions only operate on the current thread and bind the current "
"thread to the CPU it is executing on at the time. To bind an arbitrary "
"thread to a specific CPU, the `sched_bind` and `sched_unbind` functions "
"should be used instead."
msgstr ""

#. type: Title ===
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:124
#, no-wrap
msgid "Callouts"
msgstr "调出 (Callout)"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:127
msgid ""
"The `timeout` kernel facility permits kernel services to register functions "
"for execution as part of the `softclock` software interrupt. Events are "
"scheduled based on a desired number of clock ticks, and callbacks to the "
"consumer-provided function will occur at approximately the right time."
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:129
msgid ""
"The global list of pending timeout events is protected by a global spin "
"mutex, `callout_lock`; all access to the timeout list must be performed with "
"this mutex held. When `softclock` is woken up, it scans the list of pending "
"timeouts for those that should fire. In order to avoid lock order reversal, "
"the `softclock` thread will release the `callout_lock` mutex when invoking "
"the provided `timeout` callback function. If the `CALLOUT_MPSAFE` flag was "
"not set during registration, then Giant will be grabbed before invoking the "
"callout, and then released afterwards. The `callout_lock` mutex will be "
"re-grabbed before proceeding. The `softclock` code is careful to leave the "
"list in a consistent state while releasing the mutex. If `DIAGNOSTIC` is "
"enabled, then the time taken to execute each function is measured, and a "
"warning is generated if it exceeds a threshold."
msgstr ""

#. type: Title ==
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:131
#, no-wrap
msgid "Specific Locking Strategies"
msgstr "特定数据的锁策略"

#. type: Title ===
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:133
#, no-wrap
msgid "Credentials"
msgstr "凭据（Credentials）"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:136
msgid ""
"`struct ucred` is the kernel's internal credential structure, and is "
"generally used as the basis for process-driven access control within the "
"kernel. BSD-derived systems use a \"copy-on-write\" model for credential "
"data: multiple references may exist for a credential structure, and when a "
"change needs to be made, the structure is duplicated, modified, and then the "
"reference replaced. Due to wide-spread caching of the credential to "
"implement access control on open, this results in substantial memory "
"savings. With a move to fine-grained SMP, this model also saves "
"substantially on locking operations by requiring that modification only "
"occur on an unshared credential, avoiding the need for explicit "
"synchronization when consuming a known-shared credential."
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:138
msgid ""
"Credential structures with a single reference are considered mutable; shared "
"credential structures must not be modified or a race condition is risked. A "
"mutex, `cr_mtxp` protects the reference count of `struct ucred` so as to "
"maintain consistency. Any use of the structure requires a valid reference "
"for the duration of the use, or the structure may be released out from under "
"the illegitimate consumer."
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:140
msgid ""
"The `struct ucred` mutex is a leaf mutex and is implemented via a mutex pool "
"for performance reasons."
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:142
msgid ""
"Usually, credentials are used in a read-only manner for access control "
"decisions, and in this case `td_ucred` is generally preferred because it "
"requires no locking. When a process' credential is updated the `proc` lock "
"must be held across the check and update operations thus avoid races. The "
"process credential `p_ucred` must be used for check and update operations to "
"prevent time-of-check, time-of-use races."
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:144
msgid ""
"If system call invocations will perform access control after an update to "
"the process credential, the value of `td_ucred` must also be refreshed to "
"the current process value. This will prevent use of a stale credential "
"following a change. The kernel automatically refreshes the `td_ucred` "
"pointer in the thread structure from the process `p_ucred` whenever a "
"process enters the kernel, permitting use of a fresh credential for kernel "
"access control."
msgstr ""

#. type: Title ===
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:145
#, no-wrap
msgid "File Descriptors and File Descriptor Tables"
msgstr "文件描述符和文件描述符表"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:148
msgid "Details to follow."
msgstr "详细内容将在稍后增加。"

#. type: Title ===
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:149
#, no-wrap
msgid "Jail Structures"
msgstr "Jail 结构体"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:152
msgid ""
"`struct prison` stores administrative details pertinent to the maintenance "
"of jails created using the man:jail[2] API. This includes the per-jail "
"hostname, IP address, and related settings. This structure is "
"reference-counted since pointers to instances of the structure are shared by "
"many credential structures. A single mutex, `pr_mtx` protects read and write "
"access to the reference count and all mutable variables inside the struct "
"jail. Some variables are set only when the jail is created, and a valid "
"reference to the `struct prison` is sufficient to read these values. The "
"precise locking of each entry is documented via comments in "
"[.filename]#sys/jail.h#."
msgstr ""

#. type: Title ===
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:153
#, no-wrap
msgid "MAC Framework"
msgstr "MAC 框架"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:156
msgid ""
"The TrustedBSD MAC Framework maintains data in a variety of kernel objects, "
"in the form of `struct label`. In general, labels in kernel objects are "
"protected by the same lock as the remainder of the kernel object. For "
"example, the `v_label` label in `struct vnode` is protected by the vnode "
"lock on the vnode."
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:158
msgid ""
"In addition to labels maintained in standard kernel objects, the MAC "
"Framework also maintains a list of registered and active policies. The "
"policy list is protected by a global mutex (`mac_policy_list_lock`) and a "
"busy count (also protected by the mutex). Since many access control checks "
"may occur in parallel, entry to the framework for a read-only access to the "
"policy list requires holding the mutex while incrementing (and later "
"decrementing) the busy count. The mutex need not be held for the duration of "
"the MAC entry operation--some operations, such as label operations on file "
"system objects--are long-lived. To modify the policy list, such as during "
"policy registration and de-registration, the mutex must be held and the "
"reference count must be zero, to prevent modification of the list while it "
"is in use."
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:160
msgid ""
"A condition variable, `mac_policy_list_not_busy`, is available to threads "
"that need to wait for the list to become unbusy, but this condition variable "
"must only be waited on if the caller is holding no other locks, or a lock "
"order violation may be possible. The busy count, in effect, acts as a form "
"of shared/exclusive lock over access to the framework: the difference is "
"that, unlike with an sx lock, consumers waiting for the list to become "
"unbusy may be starved, rather than permitting lock order problems with "
"regards to the busy count and other locks that may be held on entry to (or "
"inside) the MAC Framework."
msgstr ""

#. type: Title ===
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:161
#, no-wrap
msgid "Modules"
msgstr "模块"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:164
msgid ""
"For the module subsystem there exists a single lock that is used to protect "
"the shared data. This lock is a shared/exclusive (SX) lock and has a good "
"chance of needing to be acquired (shared or exclusively), therefore there "
"are a few macros that have been added to make access to the lock more "
"easy. These macros can be located in [.filename]#sys/module.h# and are quite "
"basic in terms of usage. The main structures protected under this lock are "
"the `module_t` structures (when shared) and the global `modulelist_t` "
"structure, modules. One should review the related source code in "
"[.filename]#kern/kern_module.c# to further understand the locking strategy."
msgstr ""

#. type: Title ===
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:165
#, no-wrap
msgid "Newbus Device Tree"
msgstr "Newbus 设备树"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:168
msgid ""
"The newbus system will have one sx lock. Readers will hold a shared (read) "
"lock (man:sx_slock[9]) and writers will hold an exclusive (write) lock "
"(man:sx_xlock[9]). Internal functions will not do locking at all. Externally "
"visible ones will lock as needed. Those items that do not matter if the race "
"is won or lost will not be locked, since they tend to be read all over the "
"place (e.g., man:device_get_softc[9]). There will be relatively few changes "
"to the newbus data structures, so a single lock should be sufficient and not "
"impose a performance penalty."
msgstr ""

#. type: Title ===
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:169
#, no-wrap
msgid "Pipes"
msgstr "管道"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:172
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:194
msgid "..."
msgstr ""

#. type: Title ===
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:173
#, no-wrap
msgid "Processes and Threads"
msgstr "进程和线程"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:176
msgid "process hierarchy"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:178
msgid "proc locks, references"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:180
msgid ""
"thread-specific copies of proc entries to freeze during system calls, "
"including td_ucred"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:182
msgid "inter-process operations"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:184
msgid "process groups and sessions"
msgstr ""

#. type: Title ===
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:185
#, no-wrap
msgid "Scheduler"
msgstr "调度"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:188
msgid ""
"Lots of references to `sched_lock` and notes pointing at specific primitives "
"and related magic elsewhere in the document."
msgstr ""

#. type: Title ===
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:189
#, no-wrap
msgid "Select and Poll"
msgstr "Select 和 Poll"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:192
msgid ""
"The `select` and `poll` functions permit threads to block waiting on events "
"on file descriptors--most frequently, whether or not the file descriptors "
"are readable or writable."
msgstr ""

#. type: Title ===
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:195
#, no-wrap
msgid "SIGIO"
msgstr "SIGIO"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:198
msgid ""
"The SIGIO service permits processes to request the delivery of a SIGIO "
"signal to its process group when the read/write status of specified file "
"descriptors changes. At most one process or process group is permitted to "
"register for SIGIO from any given kernel object, and that process or group "
"is referred to as the owner. Each object supporting SIGIO registration "
"contains pointer field that is `NULL` if the object is not registered, or "
"points to a `struct sigio` describing the registration. This field is "
"protected by a global mutex, `sigio_lock`. Callers to SIGIO maintenance "
"functions must pass in this field \"by reference\" so that local register "
"copies of the field are not made when unprotected by the lock."
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:200
msgid ""
"One `struct sigio` is allocated for each registered object associated with "
"any process or process group, and contains back-pointers to the object, "
"owner, signal information, a credential, and the general disposition of the "
"registration. Each process or progress group contains a list of registered "
"`struct sigio` structures, `p_sigiolst` for processes, and `pg_sigiolst` for "
"process groups. These lists are protected by the process or process group "
"locks respectively. Most fields in each `struct sigio` are constant for the "
"duration of the registration, with the exception of the `sio_pgsigio` field "
"which links the `struct sigio` into the process or process group "
"list. Developers implementing new kernel objects supporting SIGIO will, in "
"general, want to avoid holding structure locks while invoking SIGIO "
"supporting functions, such as `fsetown` or `funsetown` to avoid defining a "
"lock order between structure locks and the global SIGIO lock. This is "
"generally possible through use of an elevated reference count on the "
"structure, such as reliance on a file descriptor reference to a pipe during "
"a pipe operation."
msgstr ""

#. type: Title ===
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:201
#, no-wrap
msgid "Sysctl"
msgstr "Sysctl"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:204
msgid ""
"The `sysctl` MIB service is invoked from both within the kernel and from "
"userland applications using a system call. At least two issues are raised in "
"locking: first, the protection of the structures maintaining the namespace, "
"and second, interactions with kernel variables and functions that are "
"accessed by the sysctl interface. Since sysctl permits the direct export "
"(and modification) of kernel statistics and configuration parameters, the "
"sysctl mechanism must become aware of appropriate locking semantics for "
"those variables. Currently, sysctl makes use of a single global sx lock to "
"serialize use of `sysctl`; however, it is assumed to operate under Giant and "
"other protections are not provided. The remainder of this section speculates "
"on locking and semantic changes to sysctl."
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:206
msgid ""
"Need to change the order of operations for sysctl's that update values from "
"read old, copyin and copyout, write new to copyin, lock, read old and write "
"new, unlock, copyout. Normal sysctl's that just copyout the old value and "
"set a new value that they copyin may still be able to follow the old "
"model. However, it may be cleaner to use the second model for all of the "
"sysctl handlers to avoid lock operations."
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:208
msgid ""
"To allow for the common case, a sysctl could embed a pointer to a mutex in "
"the SYSCTL_FOO macros and in the struct. This would work for most "
"sysctl's. For values protected by sx locks, spin mutexes, or other locking "
"strategies besides a single sleep mutex, SYSCTL_PROC nodes could be used to "
"get the locking right."
msgstr ""

#. type: Title ===
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:209
#, no-wrap
msgid "Taskqueue"
msgstr "任务队列 (Taskqueue)"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:212
msgid ""
"The taskqueue's interface has two basic locks associated with it in order to "
"protect the related shared data. The `taskqueue_queues_mutex` is meant to "
"serve as a lock to protect the `taskqueue_queues` TAILQ. The other mutex "
"lock associated with this system is the one in the `struct taskqueue` data "
"structure. The use of the synchronization primitive here is to protect the "
"integrity of the data in the `struct taskqueue`. It should be noted that "
"there are no separate macros to assist the user in locking down his/her own "
"work since these locks are most likely not going to be used outside of "
"[.filename]#kern/subr_taskqueue.c#."
msgstr ""

#. type: Title ==
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:214
#, no-wrap
msgid "Implementation Notes"
msgstr "实现说明"

#. type: Title ===
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:216
#, no-wrap
msgid "Sleep Queues"
msgstr "休眠队列"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:219
msgid ""
"A sleep queue is a structure that holds the list of threads asleep on a wait "
"channel. Each thread that is not asleep on a wait channel carries a sleep "
"queue structure around with it. When a thread blocks on a wait channel, it "
"donates its sleep queue structure to that wait channel. Sleep queues "
"associated with a wait channel are stored in a hash table."
msgstr ""
"休眠队列是一种用于保存同处一个等待通道 (wait channel)上休眠线程列表的数据结构。 "
"在等待通道上，每个处于非睡眠状态的线程都会携带一个休眠队列结构。当线程在等待通道上发生阻塞时， "
"它会将休眠队列结构体送给那个等待通道。与等待通道关联的休眠队列则保存在一个散列表中。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:221
msgid ""
"The sleep queue hash table holds sleep queues for wait channels that have at "
"least one blocked thread. Each entry in the hash table is called a "
"sleepqueue chain. The chain contains a linked list of sleep queues and a "
"spin mutex. The spin mutex protects the list of sleep queues as well as the "
"contents of the sleep queue structures on the list. Only one sleep queue is "
"associated with a given wait channel. If multiple threads block on a wait "
"channel than the sleep queues associated with all but the first thread are "
"stored on a list of free sleep queues in the master sleep queue. When a "
"thread is removed from the sleep queue it is given one of the sleep queue "
"structures from the master queue's free list if it is not the only thread "
"asleep on the queue. The last thread is given the master sleep queue when it "
"is resumed. Since threads may be removed from the sleep queue in a different "
"order than they are added, a thread may depart from a sleep queue with a "
"different sleep queue structure than the one it arrived with."
msgstr ""
"休眠队列散列表中保存了包含至少一个阻塞线程的等待通道上的休眠队列。这个散列表上的项称作 sleepqueue (休眠队列) 链。 "
"它包含了一个休眠队列的链表，以及一个自旋 mutex。 此处的自旋 mutex 用于保护休眠队列表，以及其上休眠队列结构的内容。 "
"一个等待通道上只会关联一个休眠队列。如果有多个线程在同一等待通道上阻塞，则休眠队列中将关联除第一个线程之外的全部线程。 "
"当从休眠队列中删除线程时，如果它不是唯一的阻塞的休眠线程， "
"则会获得主休眠队列的空闲表上的休眠队列结构。最后一个线程会在恢复运行时获得主休眠队列。由于线程有可能以和加入休眠队列不同的次序从其中删除，因此， "
"线程离开队列时可能会携带与其进入时不同的休眠队列。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:223
msgid ""
"The `sleepq_lock` function locks the spin mutex of the sleep queue chain "
"that maps to a specific wait channel. The `sleepq_lookup` function looks in "
"the hash table for the master sleep queue associated with a given wait "
"channel. If no master sleep queue is found, it returns `NULL`. The "
"`sleepq_release` function unlocks the spin mutex associated with a given "
"wait channel."
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:225
msgid ""
"A thread is added to a sleep queue via the `sleepq_add`. This function "
"accepts the wait channel, a pointer to the mutex that protects the wait "
"channel, a wait message description string, and a mask of flags. The sleep "
"queue chain should be locked via `sleepq_lock` before this function is "
"called. If no mutex protects the wait channel (or it is protected by Giant), "
"then the mutex pointer argument should be `NULL`. The flags argument "
"contains a type field that indicates the kind of sleep queue that the thread "
"is being added to and a flag to indicate if the sleep is interruptible "
"(`SLEEPQ_INTERRUPTIBLE`). Currently there are only two types of sleep "
"queues: traditional sleep queues managed via the `msleep` and `wakeup` "
"functions (`SLEEPQ_MSLEEP`) and condition variable sleep queues "
"(`SLEEPQ_CONDVAR`). The sleep queue type and lock pointer argument are used "
"solely for internal assertion checking. Code that calls `sleepq_add` should "
"explicitly unlock any interlock protecting the wait channel after the "
"associated sleepqueue chain has been locked via `sleepq_lock` and before "
"blocking on the sleep queue via one of the waiting functions."
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:227
msgid ""
"A timeout for a sleep is set by invoking `sleepq_set_timeout`. The function "
"accepts the wait channel and the timeout time as a relative tick count as "
"its arguments. If a sleep should be interrupted by arriving signals, the "
"`sleepq_catch_signals` function should be called as well. This function "
"accepts the wait channel as its only parameter. If there is already a signal "
"pending for this thread, then `sleepq_catch_signals` will return a signal "
"number; otherwise, it will return 0."
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:229
msgid ""
"Once a thread has been added to a sleep queue, it blocks using one of the "
"`sleepq_wait` functions. There are four wait functions depending on whether "
"or not the caller wishes to use a timeout or have the sleep aborted by "
"caught signals or an interrupt from the userland thread scheduler. The "
"`sleepq_wait` function simply waits until the current thread is explicitly "
"resumed by one of the wakeup functions. The `sleepq_timedwait` function "
"waits until either the thread is explicitly resumed or the timeout set by an "
"earlier call to `sleepq_set_timeout` expires. The `sleepq_wait_sig` function "
"waits until either the thread is explicitly resumed or its sleep is "
"aborted. The `sleepq_timedwait_sig` function waits until either the thread "
"is explicitly resumed, the timeout set by an earlier call to "
"`sleepq_set_timeout` expires, or the thread's sleep is aborted. All of the "
"wait functions accept the wait channel as their first parameter. In "
"addition, the `sleepq_timedwait_sig` function accepts a second boolean "
"parameter to indicate if the earlier call to `sleepq_catch_signals` found a "
"pending signal."
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:231
msgid ""
"If the thread is explicitly resumed or is aborted by a signal, then a value "
"of zero is returned by the wait function to indicate a successful sleep. If "
"the thread is resumed by either a timeout or an interrupt from the userland "
"thread scheduler then an appropriate errno value is returned instead. Note "
"that since `sleepq_wait` can only return 0 it does not return anything and "
"the caller should assume a successful sleep. Also, if a thread's sleep times "
"out and is aborted simultaneously then `sleepq_timedwait_sig` will return an "
"error indicating that a timeout occurred. If an error value of 0 is returned "
"and either `sleepq_wait_sig` or `sleepq_timedwait_sig` was used to block, "
"then the function `sleepq_calc_signal_retval` should be called to check for "
"any pending signals and calculate an appropriate return value if any are "
"found. The signal number returned by the earlier call to "
"`sleepq_catch_signals` should be passed as the sole argument to "
"`sleepq_calc_signal_retval`."
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:233
msgid ""
"Threads asleep on a wait channel are explicitly resumed by the "
"`sleepq_broadcast` and `sleepq_signal` functions. Both functions accept the "
"wait channel from which to resume threads, a priority to raise resumed "
"threads to, and a flags argument to indicate which type of sleep queue is "
"being resumed. The priority argument is treated as a minimum priority. If a "
"thread being resumed already has a higher priority (numerically lower) than "
"the priority argument then its priority is not adjusted. The flags argument "
"is used for internal assertions to ensure that sleep queues are not being "
"treated as the wrong type. For example, the condition variable functions "
"should not resume threads on a traditional sleep queue. The "
"`sleepq_broadcast` function resumes all threads that are blocked on the "
"specified wait channel while `sleepq_signal` only resumes the highest "
"priority thread blocked on the wait channel. The sleep queue chain should "
"first be locked via the `sleepq_lock` function before calling these "
"functions."
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:235
msgid ""
"A sleeping thread may have its sleep interrupted by calling the "
"`sleepq_abort` function. This function must be called with `sched_lock` held "
"and the thread must be queued on a sleep queue. A thread may also be removed "
"from a specific sleep queue via the `sleepq_remove` function. This function "
"accepts both a thread and a wait channel as an argument and only awakens the "
"thread if it is on the sleep queue for the specified wait channel. If the "
"thread is not on a sleep queue or it is on a sleep queue for a different "
"wait channel, then this function does nothing."
msgstr ""

#. type: Title ===
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:236
#, no-wrap
msgid "Turnstiles"
msgstr "十字转门 (turnstile)"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:239
msgid "Compare/contrast with sleep queues."
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:241
msgid "Lookup/wait/release. - Describe TDF_TSNOBLOCK race."
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:243
msgid "Priority propagation."
msgstr ""

#. type: Title ===
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:244
#, no-wrap
msgid "Details of the Mutex Implementation"
msgstr "关于 mutex 实现的一些细节"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:247
msgid ""
"Should we require mutexes to be owned for mtx_destroy() since we can not "
"safely assert that they are unowned by anyone else otherwise?"
msgstr ""

#. type: Title ====
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:248
#, no-wrap
msgid "Spin Mutexes"
msgstr "自旋 mutex"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:251
msgid "Use a critical section..."
msgstr ""

#. type: Title ====
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:252
#, no-wrap
msgid "Sleep Mutexes"
msgstr "休眠 mutex"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:255
msgid "Describe the races with contested mutexes"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:257
msgid ""
"Why it is safe to read mtx_lock of a contested mutex when holding the "
"turnstile chain lock."
msgstr ""

#. type: Title ===
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:258
#, no-wrap
msgid "Witness"
msgstr "Witness"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:261
msgid "What does it do"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:263
msgid "How does it work"
msgstr ""

#. type: Title ==
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:265
#, no-wrap
msgid "Miscellaneous Topics"
msgstr "其它话题"

#. type: Title ===
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:267
#, no-wrap
msgid "Interrupt Source and ICU Abstractions"
msgstr "中断源和 ICU 抽象"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:270
msgid "struct isrc"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:272
msgid "pic drivers"
msgstr ""

#. type: Title ===
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:273
#, no-wrap
msgid "Other Random Questions/Topics"
msgstr "其它问题/话题"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:276
msgid "Should we pass an interlock into `sema_wait`?"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:278
msgid "Should we have non-sleepable sx locks?"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:280
msgid "Add some info about proper use of reference counts."
msgstr ""

#. type: Title ==
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:285
#, no-wrap
msgid "Glossary"
msgstr "术语表"

#. type: Labeled list
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:288
#, no-wrap
msgid "atomic"
msgstr "原子"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:290
msgid ""
"An operation is atomic if all of its effects are visible to other CPUs "
"together when the proper access protocol is followed. In the degenerate case "
"are atomic instructions provided directly by machine architectures. At a "
"higher level, if several members of a structure are protected by a lock, "
"then a set of operations are atomic if they are all performed while holding "
"the lock without releasing the lock in between any of the operations."
msgstr ""
"当遵循适当的访问协议时， 如果一操作的效果对其它所有 CPU均可见， 则称其为原子操作。 狭义的原子操作是机器直接提供的。就更高的抽象层次而言， "
"如果结构体的多个成员由一个锁保护，则如果对它们的操作都是在上锁后、 解锁前进行的，也可以称其为原子操作。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:292
msgid "See Also operation."
msgstr ""

#. type: Labeled list
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:293
#, no-wrap
msgid "block"
msgstr "阻塞块"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:295
msgid ""
"A thread is blocked when it is waiting on a lock, resource, or "
"condition. Unfortunately this term is a bit overloaded as a result."
msgstr "线程等待锁、 资源或条件时被阻塞。这一术语也因此被赋予了太多的意涵。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:297
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:334
msgid "See Also sleep."
msgstr ""

#. type: Labeled list
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:298
#, no-wrap
msgid "critical section"
msgstr "临界区"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:300
msgid ""
"A section of code that is not allowed to be preempted. A critical section is "
"entered and exited using the man:critical_enter[9] API."
msgstr ""

#. type: Labeled list
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:301
#, no-wrap
msgid "MD"
msgstr "MD (Machine dependent)"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:303
msgid "Machine dependent."
msgstr "表示与机器/平台有关。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:305
msgid "See Also MI."
msgstr ""

#. type: Labeled list
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:306
#, no-wrap
msgid "memory operation"
msgstr "内存操作"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:308
msgid "A memory operation reads and/or writes to a memory location."
msgstr "内存操作包括读或写内存中的指定位置。"

#. type: Labeled list
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:309
#, no-wrap
msgid "MI"
msgstr "MI （Machine independent）"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:311
msgid "Machine independent."
msgstr "表示与机器/平台无关。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:313
msgid "See Also MD."
msgstr ""

#. type: Labeled list
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:314
#, no-wrap
msgid "operation"
msgstr "操作"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:316
msgid "See memory operation."
msgstr ""

#. type: Labeled list
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:317
#, no-wrap
msgid "primary interrupt context"
msgstr "主中断上下文"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:319
msgid ""
"Primary interrupt context refers to the code that runs when an interrupt "
"occurs. This code can either run an interrupt handler directly or schedule "
"an asynchronous interrupt thread to execute the interrupt handlers for a "
"given interrupt source."
msgstr ""
"主中断上下文表示当发生中断时所执行的那段代码。这些代码可以直接运行某个中断处理程序， 或调度一异步终端线程，以便为给定的中断源执行中断处理程序。"

#. type: Labeled list
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:320
#, no-wrap
msgid "realtime kernel thread"
msgstr "实时内核线程"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:322
msgid ""
"A high priority kernel thread. Currently, the only realtime priority kernel "
"threads are interrupt threads."
msgstr "一种高优先级的内核线程。 目前，只有中断线程属于实时优先级的内核线程。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:324
msgid "See Also thread."
msgstr ""

#. type: Labeled list
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:325
#, no-wrap
msgid "sleep"
msgstr "睡眠"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:327
msgid ""
"A thread is asleep when it is blocked on a condition variable or a sleep "
"queue via msleep or tsleep."
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:329
msgid "See Also block."
msgstr ""

#. type: Labeled list
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:330
#, no-wrap
msgid "sleepable lock"
msgstr "可休眠锁"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:332
msgid ""
"A sleepable lock is a lock that can be held by a thread which is "
"asleep. Lockmgr locks and sx locks are currently the only sleepable locks in "
"FreeBSD. Eventually, some sx locks such as the allproc and proctree locks "
"may become non-sleepable locks."
msgstr ""
"可休眠锁是一种在进程休眠时仍可持有的锁。锁管理器 (lockmgr) 锁和 sx 锁是目前 FreeBSD 中仅有的可休眠锁。最终， 某些 sx 锁， "
"例如 allproc (全部进程) 和 proctree (进程树)锁将成为不可休眠锁。"

#. type: Labeled list
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:335
#, no-wrap
msgid "thread"
msgstr "线程"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:337
msgid ""
"A kernel thread represented by a struct thread. Threads own locks and hold a "
"single execution context."
msgstr "由 struct thread 所表达的内核线程。 线程可以持有锁，并拥有独立的执行上下文。"

#. type: Labeled list
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:338
#, no-wrap
msgid "wait channel"
msgstr "等待通道"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/chapter.adoc:340
msgid "A kernel virtual address that threads may sleep on."
msgstr "线程可以在其上休眠的内核虚拟地址。"
