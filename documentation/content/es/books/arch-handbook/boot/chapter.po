# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR The FreeBSD Project
# This file is distributed under the same license as the FreeBSD Documentation package.
# Fernando  Apesteguía <fernando.apesteguia@gmail.com>, 2021.
msgid ""
msgstr ""
"Project-Id-Version: FreeBSD Documentation VERSION\n"
"POT-Creation-Date: 2021-02-21 18:54-0300\n"
"PO-Revision-Date: 2021-04-09 02:20+0000\n"
"Last-Translator: Anonymous <noreply@weblate.org>\n"
"Language-Team: Spanish <https://translate-dev.freebsd.org/projects/"
"documentation/booksarch-handbookbootchapter/es/>\n"
"Language: es\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=n != 1;\n"
"X-Generator: Weblate 4.5.2\n"

#. type: YAML Front Matter: title
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:1
#, no-wrap
msgid "Chapter 1. Bootstrapping and Kernel Initialization"
msgstr ""

#. type: Title =
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:8
#, no-wrap
msgid "Bootstrapping and Kernel Initialization"
msgstr "Bootstrapping e inicialización del núcleo"

#. type: Title ==
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:33
#, no-wrap
msgid "Synopsis"
msgstr "Sinopsis"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:36
#, fuzzy
msgid ""
"This chapter is an overview of the boot and system initialization processes, "
"starting from the BIOS (firmware) POST, to the first user process creation. "
"Since the initial steps of system startup are very architecture dependent, "
"the IA-32 architecture is used as an example."
msgstr ""
"Este capítulo es una descripción general de los procesos de inicio y de "
"inicialización del sistema, comenzando por <acronym>BIOS</acronym> (firmware)"
" <acronym>POST</acronym>, a la creación del primer proceso de usuario. Dado "
"que los pasos iniciales del inicio del sistema dependen en gran medida de la "
"arquitectura, se utiliza la arquitectura IA-32 como ejemplo."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:38
#, fuzzy
msgid ""
"The FreeBSD boot process can be surprisingly complex. After control is "
"passed from the BIOS, a considerable amount of low-level configuration must "
"be done before the kernel can be loaded and executed. This setup must be "
"done in a simple and flexible manner, allowing the user a great deal of "
"customization possibilities."
msgstr ""
"El proceso de arranque de FreeBSD puede ser sorprendentemente complejo. Una "
"vez que se pasa el control del <acronym>BIOS</acronym>, se debe realizar una "
"cantidad considerable de configuración de bajo nivel antes de que se pueda "
"cargar y ejecutar el kernel. Esta configuración debe realizarse de forma "
"sencilla y flexible, permitiendo al usuario una gran cantidad de "
"posibilidades de personalización."

#. type: Title ==
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:40
#, no-wrap
msgid "Overview"
msgstr "Visión general"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:43
#, fuzzy
msgid ""
"The boot process is an extremely machine-dependent activity. Not only must "
"code be written for every computer architecture, but there may also be "
"multiple types of booting on the same architecture. For example, a directory "
"listing of [.filename]#/usr/src/sys/boot# reveals a great amount of "
"architecture-dependent code. There is a directory for each of the various "
"supported architectures. In the x86-specific [.filename]#i386# directory, "
"there are subdirectories for different boot standards like [.filename]#mbr# "
"(Master Boot Record), [.filename]#gpt# (GUID Partition Table), and [."
"filename]#efi# (Extensible Firmware Interface). Each boot standard has its "
"own conventions and data structures. The example that follows shows booting "
"an x86 computer from an MBR hard drive with the FreeBSD [.filename]#boot0# "
"multi-boot loader stored in the very first sector. That boot code starts the "
"FreeBSD three-stage boot process."
msgstr ""
"el proceso de arranque es una actividad extremadamente dependiente de la "
"máquina. No solo se debe escribir código para cada arquitectura de "
"computadora, sino que también puede haber varios tipos de arranque en la "
"misma arquitectura. Por ejemplo, una lista de directorio de <filename>/usr/"
"src/sys/boot</filename> revela una gran cantidad de código dependiente de la "
"arquitectura. Hay un directorio para cada una de las diversas arquitecturas "
"compatibles. En el x86 específico <filename>i386</filename> directorio, hay "
"subdirectorios para diferentes estándares de arranque como <filename>mbr</"
"filename> (Registro de arranque principal), <filename>gpt</filename> "
"(<acronym>GUID</acronym>Tabla de particiones), y <filename>efi</filename> ("
"Interfaz de firmware extensible). Cada estándar de arranque tiene sus "
"propias convenciones y estructuras de datos. El siguiente ejemplo muestra "
"cómo arrancar una computadora x86 desde una <acronym>MBR</acronym> disco "
"duro con FreeBSD <filename>boot0</filename> cargador de arranque múltiple "
"almacenado en el primer sector. Ese código de arranque inicia el proceso de "
"arranque de tres etapas de FreeBSD."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:45
msgid ""
"The key to understanding this process is that it is a series of stages of "
"increasing complexity. These stages are [.filename]#boot1#, [."
"filename]#boot2#, and [.filename]#loader# (see man:boot[8] for more detail). "
"The boot system executes each stage in sequence. The last stage, [."
"filename]#loader#, is responsible for loading the FreeBSD kernel. Each stage "
"is examined in the following sections."
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:47
msgid ""
"Here is an example of the output generated by the different boot stages. "
"Actual output may differ from machine to machine:"
msgstr ""
"A continuación, se muestra un ejemplo de la salida generada por las "
"diferentes etapas de arranque. La producción real puede diferir de una "
"máquina a otra:"

#. type: Table
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:58
#, no-wrap
msgid ""
"|*FreeBSD Component*\n"
"|*Output (may vary)*\n"
"\n"
"|`boot0`\n"
"a|\n"
"\n"
msgstr ""

#. type: Table
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:68
#, no-wrap
msgid ""
"....\n"
"F1    FreeBSD\n"
"F2    BSD\n"
"F5    Disk 2\n"
"....\n"
"\n"
"|`boot2` footnote:[This prompt will appear if the user presses a key just after selecting an OS to boot at the boot0 stage.]\n"
"a|\n"
"\n"
msgstr ""

#. type: Table
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:78
msgid ""
"....  >>FreeBSD/i386 BOOT Default: 1:ad(1,a)/boot/loader boot: ....  |[."
"filename]#loader# a|"
msgstr ""

#. type: Table
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:95
msgid ""
"....  BTX loader 1.00 BTX version is 1.02 Consoles: internal video/keyboard "
"BIOS drive C: is disk0 BIOS 639kB/2096064kB available memory FreeBSD/x86 "
"bootstrap loader, Revision 1.1 Console internal video/keyboard (root@snap."
"freebsd.org, Thu Jan 16 22:18:05 UTC 2014)  Loading /boot/defaults/loader."
"conf /boot/kernel/kernel text=0xed9008 data=0x117d28+0x176650 "
"syms=[0x8+0x137988+0x8+0x1515f8] ....  |kernel a|"
msgstr ""

#. type: Table
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:106
#, no-wrap
msgid ""
"....\n"
"Copyright (c) 1992-2013 The FreeBSD Project.\n"
"Copyright (c) 1979, 1980, 1983, 1986, 1988, 1989, 1991, 1992, 1993, 1994\n"
"        The Regents of the University of California. All rights reserved.\n"
"FreeBSD is a registered trademark of The FreeBSD Foundation.\n"
"FreeBSD 10.0-RELEASE 0 r260789: Thu Jan 16 22:34:59 UTC 2014\n"
"    root@snap.freebsd.org:/usr/obj/usr/src/sys/GENERIC amd64\n"
"FreeBSD clang version 3.3 (tags/RELEASE_33/final 183502) 20130610\n"
"....\n"
"\n"
msgstr ""

#. type: Title ==
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:109
#, no-wrap
msgid "The BIOS"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:112
#, fuzzy
msgid ""
"When the computer powers on, the processor's registers are set to some "
"predefined values. One of the registers is the _instruction pointer_ "
"register, and its value after a power on is well defined: it is a 32-bit "
"value of `0xfffffff0`. The instruction pointer register (also known as the "
"Program Counter) points to code to be executed by the processor. Another "
"important register is the `cr0` 32-bit control register, and its value just "
"after a reboot is `0`. One of ``cr0``'s bits, the PE (Protection Enabled) "
"bit, indicates whether the processor is running in 32-bit protected mode or "
"16-bit real mode. Since this bit is cleared at boot time, the processor "
"boots in 16-bit real mode. Real mode means, among other things, that linear "
"and physical addresses are identical. The reason for the processor not to "
"start immediately in 32-bit protected mode is backwards compatibility. In "
"particular, the boot process relies on the services provided by the BIOS, "
"and the BIOS itself works in legacy, 16-bit code."
msgstr ""
"Cuando la computadora se enciende, los registros del procesador se "
"establecen en algunos valores predefinidos. Uno de los registros es el "
"<emphasis>puntero de instrucción</emphasis>registro, y su valor después de "
"un encendido está bien definido: es un valor de 32 bits de "
"<literal>0xfffffff0</literal>. El registro de puntero de instrucción ("
"también conocido como Contador de programa) apunta al código que debe "
"ejecutar el procesador. Otro registro importante es el <literal>cr0</"
"literal> Registro de control de 32 bits, y su valor justo después de un "
"reinicio es <literal>0</literal>. Uno de <literal>cr0</literal>'sbits, el "
"bit PE (protección habilitada), indica si el procesador está funcionando en "
"modo protegido de 32 bits o en modo real de 16 bits. Dado que este bit se "
"borra en el momento del arranque, el procesador arranca en modo real de 16 "
"bits. El modo real significa, entre otras cosas, que las direcciones "
"lineales y físicas son idénticas. La razón por la que el procesador no se "
"inicia inmediatamente en el modo protegido de 32 bits es la compatibilidad "
"con versiones anteriores. En particular, el proceso de arranque se basa en "
"los servicios proporcionados por el <acronym>BIOS</acronym>, y el "
"<acronym>BIOS</acronym> sí mismo funciona en código heredado de 16 bits."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:114
msgid ""
"The value of `0xfffffff0` is slightly less than 4 GB, so unless the machine "
"has 4 GB of physical memory, it cannot point to a valid memory address. The "
"computer's hardware translates this address so that it points to a BIOS "
"memory block."
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:116
#, fuzzy
msgid ""
"The BIOS (Basic Input Output System) is a chip on the motherboard that has a "
"relatively small amount of read-only memory (ROM). This memory contains "
"various low-level routines that are specific to the hardware supplied with "
"the motherboard. The processor will first jump to the address 0xfffffff0, "
"which really resides in the BIOS's memory. Usually this address contains a "
"jump instruction to the BIOS's POST routines."
msgstr ""
"El <acronym>BIOS</acronym> (Basic Input Output System) es un chip en la "
"placa base que tiene una cantidad relativamente pequeña de memoria de solo "
"lectura(<acronym>ROM</acronym>). Esta memoria contiene varias rutinas de "
"bajo nivel que son específicas del hardware suministrado con la placa base. "
"El procesador primero saltará a la dirección 0xfffffff0, que realmente "
"reside en el <acronym>BIOS</acronym>'s memoria. Por lo general, esta "
"dirección contiene una instrucción de salto al <acronym>BIOS</acronym>'s "
"Rutinas POSTERIORES"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:118
#, fuzzy
msgid ""
"The POST (Power On Self Test) is a set of routines including the memory "
"check, system bus check, and other low-level initialization so the CPU can "
"set up the computer properly. The important step of this stage is "
"determining the boot device. Modern BIOS implementations permit the "
"selection of a boot device, allowing booting from a floppy, CD-ROM, hard "
"disk, or other devices."
msgstr ""
"El <acronym>POST</acronym> (Power On Self Test) es un conjunto de rutinas "
"que incluyen la verificación de la memoria, la verificación del bus del "
"sistema y otras inicializaciones de bajo nivel para que el <acronym>CPU</"
"acronym> puede configurar la computadora correctamente. El paso importante "
"de esta etapa es determinar el dispositivo de arranque. Moderno "
"<acronym>BIOS</acronym> Las implementaciones permiten la selección de un "
"dispositivo de arranque, lo que permite arrancar desde un disquete,<acronym"
">CD-ROM</acronym>, disco duro u otros dispositivos."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:120
msgid ""
"The very last thing in the POST is the `INT 0x19` instruction. The `INT "
"0x19` handler reads 512 bytes from the first sector of boot device into the "
"memory at address `0x7c00`. The term _first sector_ originates from hard "
"drive architecture, where the magnetic plate is divided into a number of "
"cylindrical tracks. Tracks are numbered, and every track is divided into a "
"number (usually 64) of sectors. Track numbers start at 0, but sector numbers "
"start from 1. Track 0 is the outermost on the magnetic plate, and sector 1, "
"the first sector, has a special purpose. It is also called the MBR, or "
"Master Boot Record. The remaining sectors on the first track are never used."
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:122
msgid ""
"This sector is our boot-sequence starting point. As we will see, this sector "
"contains a copy of our [.filename]#boot0# program. A jump is made by the "
"BIOS to address `0x7c00` so it starts executing."
msgstr ""

#. type: Title ==
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:124
#, no-wrap
msgid "The Master Boot Record (`boot0`)"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:127
msgid ""
"After control is received from the BIOS at memory address `0x7c00`, [."
"filename]#boot0# starts executing. It is the first piece of code under "
"FreeBSD control. The task of [.filename]#boot0# is quite simple: scan the "
"partition table and let the user choose which partition to boot from. The "
"Partition Table is a special, standard data structure embedded in the MBR "
"(hence embedded in [.filename]#boot0#) describing the four standard PC "
"\"partitions\". [.filename]#boot0# resides in the filesystem as [.filename]#/"
"boot/boot0#. It is a small 512-byte file, and it is exactly what FreeBSD's "
"installation procedure wrote to the hard disk's MBR if you chose the "
"\"bootmanager\" option at installation time. Indeed, [.filename]#boot0#_is_ "
"the MBR."
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:129
msgid ""
"As mentioned previously, the `INT 0x19` instruction causes the `INT 0x19` "
"handler to load an MBR ([.filename]#boot0#) into memory at address `0x7c00`. "
"The source file for [.filename]#boot0# can be found in [.filename]#sys/boot/"
"i386/boot0/boot0.S# - which is an awesome piece of code written by Robert "
"Nordier."
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:131
msgid ""
"A special structure starting from offset `0x1be` in the MBR is called the "
"_partition table_. It has four records of 16 bytes each, called _partition "
"records_, which represent how the hard disk is partitioned, or, in FreeBSD's "
"terminology, sliced. One byte of those 16 says whether a partition (slice) "
"is bootable or not. Exactly one record must have that flag set, otherwise [."
"filename]#boot0#'s code will refuse to proceed."
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:133
msgid "A partition record has the following fields:"
msgstr "Un registro de partición tiene los siguientes campos:"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:135
msgid "the 1-byte filesystem type"
msgstr "el tipo de sistema de archivos de 1 byte"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:136
msgid "the 1-byte bootable flag"
msgstr "el indicador de arranque de 1 byte"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:137
msgid "the 6 byte descriptor in CHS format"
msgstr "el descriptor de 6 bytes en formato CHS"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:138
msgid "the 8 byte descriptor in LBA format"
msgstr "el descriptor de 8 bytes en formato LBA"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:140
msgid ""
"A partition record descriptor contains information about where exactly the "
"partition resides on the drive. Both descriptors, LBA and CHS, describe the "
"same information, but in different ways: LBA (Logical Block Addressing) has "
"the starting sector for the partition and the partition's length, while CHS "
"(Cylinder Head Sector) has coordinates for the first and last sectors of the "
"partition. The partition table ends with the special signature `0xaa55`."
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:142
#, fuzzy
msgid ""
"The MBR must fit into 512 bytes, a single disk sector. This program uses low-"
"level \"tricks\" like taking advantage of the side effects of certain "
"instructions and reusing register values from previous operations to make "
"the most out of the fewest possible instructions. Care must also be taken "
"when handling the partition table, which is embedded in the MBR itself. For "
"these reasons, be very careful when modifying [.filename]#boot0.S#."
msgstr ""
"El <acronym>MBR</acronym> debe caber en 512 bytes, un solo sector de disco. "
"Este programa utiliza bajo nivel <quote>tricks</quote> como aprovechar los "
"efectos secundarios de ciertas instrucciones y reutilizar los valores de "
"registro de operaciones anteriores para aprovechar al máximo la menor "
"cantidad de instrucciones posibles. También se debe tener cuidado al "
"manipular la tabla de partición, que está incrustada en el <acronym>MBR</"
"acronym> sí mismo. Por estas razones, tenga mucho cuidado al "
"modificar<filename>boot0.S</filename>."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:144
msgid ""
"Note that the [.filename]#boot0.S# source file is assembled \"as is\": "
"instructions are translated one by one to binary, with no additional "
"information (no ELF file format, for example). This kind of low-level "
"control is achieved at link time through special control flags passed to the "
"linker. For example, the text section of the program is set to be located at "
"address `0x600`. In practice this means that [.filename]#boot0# must be "
"loaded to memory address `0x600` in order to function properly."
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:146
msgid ""
"It is worth looking at the [.filename]#Makefile# for [.filename]#boot0# ([."
"filename]#sys/boot/i386/boot0/Makefile#), as it defines some of the run-time "
"behavior of [.filename]#boot0#. For instance, if a terminal connected to the "
"serial port (COM1) is used for I/O, the macro `SIO` must be defined (`-"
"DSIO`). `-DPXE` enables boot through PXE by pressing kbd:[F6]. Additionally, "
"the program defines a set of _flags_ that allow further modification of its "
"behavior. All of this is illustrated in the [.filename]#Makefile#. For "
"example, look at the linker directives which command the linker to start the "
"text section at address `0x600`, and to build the output file \"as is"
"\" (strip out any file formatting):"
msgstr ""

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:152
#, no-wrap
msgid ""
"      BOOT_BOOT0_ORG?=0x600\n"
"      LDFLAGS=-e start -Ttext ${BOOT_BOOT0_ORG} \\\n"
"      -Wl,-N,-S,--oformat,binary\n"
msgstr ""

#. type: Block title
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:154
#, no-wrap
msgid "[.filename]#sys/boot/i386/boot0/Makefile# [[boot-boot0-makefile-as-is]]"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:156
msgid ""
"Let us now start our study of the MBR, or [.filename]#boot0#, starting where "
"execution begins."
msgstr ""

#. type: delimited block = 4
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:160
msgid ""
"Some modifications have been made to some instructions in favor of better "
"exposition. For example, some macros are expanded, and some macro tests are "
"omitted when the result of the test is known. This applies to all of the "
"code examples shown."
msgstr ""
"Se han realizado algunas modificaciones a algunas instrucciones a favor de "
"una mejor exposición. Por ejemplo, algunas macros se expanden y algunas "
"macropruebas se omiten cuando se conoce el resultado de la prueba. Esto se "
"aplica a todos los ejemplos de código que se muestran."

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:171
#, no-wrap
msgid ""
"start:\n"
"      cld\t\t\t# String ops inc\n"
"      xorw %ax,%ax\t\t# Zero\n"
"      movw %ax,%es\t\t# Address\n"
"      movw %ax,%ds\t\t#  data\n"
"      movw %ax,%ss\t\t# Set up\n"
"      movw 0x7c00,%sp\t\t#  stack\n"
msgstr ""

#. type: Block title
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:173
#, no-wrap
msgid "[.filename]#sys/boot/i386/boot0/boot0.S# [[boot-boot0-entrypoint]]"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:175
msgid ""
"This first block of code is the entry point of the program. It is where the "
"BIOS transfers control. First, it makes sure that the string operations "
"autoincrement its pointer operands (the `cld` instruction) footnote:[When in "
"doubt, we refer the reader to the official Intel manuals, which describe the "
"exact semantics for each instruction: .]. Then, as it makes no assumption "
"about the state of the segment registers, it initializes them. Finally, it "
"sets the stack pointer register (`%sp`) to address `0x7c00`, so we have a "
"working stack."
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:177
msgid ""
"The next block is responsible for the relocation and subsequent jump to the "
"relocated code."
msgstr ""
"El siguiente bloque es responsable de la reubicación y el posterior salto al "
"código reubicado."

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:191
#, no-wrap
msgid ""
"      movw $0x7c00,%si\t# Source\n"
"      movw $0x600,%di\t\t# Destination\n"
"      movw $512,%cx\t\t# Word count\n"
"      rep\t\t\t# Relocate\n"
"      movsb\t\t\t#  code\n"
"      movw %di,%bp\t\t# Address variables\n"
"      movb $16,%cl\t\t# Words to clear\n"
"      rep\t\t\t# Zero\n"
"      stosb\t\t\t#  them\n"
"      incb -0xe(%di)\t\t# Set the S field to 1\n"
"      jmp main-0x7c00+0x600\t# Jump to relocated code\n"
msgstr ""

#. type: Block title
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:193
#, no-wrap
msgid "[.filename]#sys/boot/i386/boot0/boot0.S# [[boot-boot0-relocation]]"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:195
msgid ""
"As [.filename]#boot0# is loaded by the BIOS to address `0x7C00`, it copies "
"itself to address `0x600` and then transfers control there (recall that it "
"was linked to execute at address `0x600`). The source address, `0x7c00`, is "
"copied to register `%si`. The destination address, `0x600`, to register `"
"%di`. The number of bytes to copy, `512` (the program's size), is copied to "
"register `%cx`. Next, the `rep` instruction repeats the instruction that "
"follows, that is, `movsb`, the number of times dictated by the `%cx` "
"register. The `movsb` instruction copies the byte pointed to by `%si` to the "
"address pointed to by `%di`. This is repeated another 511 times. On each "
"repetition, both the source and destination registers, `%si` and `%di`, are "
"incremented by one. Thus, upon completion of the 512-byte copy, `%di` has "
"the value `0x600`+`512`= `0x800`, and `%si` has the value `0x7c00`+`512`= "
"`0x7e00`; we have thus completed the code _relocation_."
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:197
msgid ""
"Next, the destination register `%di` is copied to `%bp`. `%bp` gets the "
"value `0x800`. The value `16` is copied to `%cl` in preparation for a new "
"string operation (like our previous `movsb`). Now, `stosb` is executed 16 "
"times. This instruction copies a `0` value to the address pointed to by the "
"destination register (`%di`, which is `0x800`), and increments it. This is "
"repeated another 15 times, so `%di` ends up with value `0x810`. Effectively, "
"this clears the address range `0x800`-`0x80f`. This range is used as a "
"(fake) partition table for writing the MBR back to disk. Finally, the sector "
"field for the CHS addressing of this fake partition is given the value 1 and "
"a jump is made to the main function from the relocated code. Note that until "
"this jump to the relocated code, any reference to an absolute address was "
"avoided."
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:199
msgid ""
"The following code block tests whether the drive number provided by the BIOS "
"should be used, or the one stored in [.filename]#boot0#."
msgstr ""

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:207
#, no-wrap
msgid ""
"main:\n"
"      testb $SETDRV,-69(%bp)\t# Set drive number?\n"
"      jnz disable_update\t# Yes\n"
"      testb %dl,%dl\t\t# Drive number valid?\n"
"      js save_curdrive\t\t# Possibly (0x80 set)\n"
msgstr ""

#. type: Block title
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:209
#, no-wrap
msgid "[.filename]#sys/boot/i386/boot0/boot0.S# [[boot-boot0-drivenumber]]"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:211
msgid ""
"This code tests the `SETDRV` bit (`0x20`) in the _flags_ variable. Recall "
"that register `%bp` points to address location `0x800`, so the test is done "
"to the _flags_ variable at address `0x800`-`69`= `0x7bb`. This is an example "
"of the type of modifications that can be done to [.filename]#boot0#. The "
"`SETDRV` flag is not set by default, but it can be set in the [."
"filename]#Makefile#. When set, the drive number stored in the MBR is used "
"instead of the one provided by the BIOS. We assume the defaults, and that "
"the BIOS provided a valid drive number, so we jump to `save_curdrive`."
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:213
msgid ""
"The next block saves the drive number provided by the BIOS, and calls `putn` "
"to print a new line on the screen."
msgstr ""

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:225
#, no-wrap
msgid ""
"save_curdrive:\n"
"      movb %dl, (%bp)\t\t# Save drive number\n"
"      pushw %dx\t\t\t# Also in the stack\n"
"#ifdef\tTEST\t/* test code, print internal bios drive */\n"
"      rolb $1, %dl\n"
"      movw $drive, %si\n"
"      call putkey\n"
"#endif\n"
"      callw putn\t\t# Print a newline\n"
msgstr ""

#. type: Block title
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:227
#, no-wrap
msgid "[.filename]#sys/boot/i386/boot0/boot0.S# [[boot-boot0-savedrivenumber]]"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:229
#, fuzzy
msgid ""
"Note that we assume `TEST` is not defined, so the conditional code in it is "
"not assembled and will not appear in our executable [.filename]#boot0#."
msgstr ""
"Tenga en cuenta que asumimos <varname>TEST</varname> no está definido, por "
"lo que el código condicional que contiene no está ensamblado y no aparecerá "
"en nuestro ejecutable <filename>boot0</filename>."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:231
msgid ""
"Our next block implements the actual scanning of the partition table. It "
"prints to the screen the partition type for each of the four entries in the "
"partition table. It compares each type with a list of well-known operating "
"system file systems. Examples of recognized partition types are NTFS "
"(Windows(R), ID 0x7), `ext2fs` (Linux(R), ID 0x83), and, of course, `ffs`/"
"`ufs2` (FreeBSD, ID 0xa5). The implementation is fairly simple."
msgstr ""

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:236
#, no-wrap
msgid ""
"      movw $(partbl+0x4),%bx\t# Partition table (+4)\n"
"      xorw %dx,%dx\t\t# Item number\n"
msgstr ""

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:252
#, no-wrap
msgid ""
"read_entry:\n"
"      movb %ch,-0x4(%bx)\t# Zero active flag (ch == 0)\n"
"      btw %dx,_FLAGS(%bp)\t# Entry enabled?\n"
"      jnc next_entry\t\t# No\n"
"      movb (%bx),%al\t\t# Load type\n"
"      test %al, %al\t\t# skip empty partition\n"
"      jz next_entry\n"
"      movw $bootable_ids,%di\t# Lookup tables\n"
"      movb $(TLEN+1),%cl\t# Number of entries\n"
"      repne\t\t\t# Locate\n"
"      scasb\t\t\t#  type\n"
"      addw $(TLEN-1), %di\t# Adjust\n"
"      movb (%di),%cl\t\t# Partition\n"
"      addw %cx,%di\t\t#  description\n"
"      callw putx\t\t# Display it\n"
msgstr ""

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:257
#, no-wrap
msgid ""
"next_entry:\n"
"      incw %dx\t\t\t# Next item\n"
"      addb $0x10,%bl\t\t# Next entry\n"
"      jnc read_entry\t\t# Till done\n"
msgstr ""

#. type: Block title
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:259
#, no-wrap
msgid "[.filename]#sys/boot/i386/boot0/boot0.S# [[boot-boot0-partition-scan]]"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:261
#, fuzzy
msgid ""
"It is important to note that the active flag for each entry is cleared, so "
"after the scanning, _no_ partition entry is active in our memory copy of [."
"filename]#boot0#. Later, the active flag will be set for the selected "
"partition. This ensures that only one active partition exists if the user "
"chooses to write the changes back to disk."
msgstr ""
"Es importante tener en cuenta que la bandera activa para cada entrada se "
"borra, por lo que después del escaneo, <emphasis>no</emphasis> La entrada de "
"partición está activa en nuestra copia de memoria de <filename>boot0</"
"filename>. posteriormente, la bandera activa se establecerá para la "
"partición seleccionada. Esto asegura que solo exista una partición activa si "
"el usuario elige volver a escribir los cambios en el disco."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:263
msgid ""
"The next block tests for other drives. At startup, the BIOS writes the "
"number of drives present in the computer to address `0x475`. If there are "
"any other drives present, [.filename]#boot0# prints the current drive to "
"screen. The user may command [.filename]#boot0# to scan partitions on "
"another drive later."
msgstr ""

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:272
#, no-wrap
msgid ""
"      popw %ax\t\t\t# Drive number\n"
"      subb $0x79,%al\t\t# Does next\n"
"      cmpb 0x475,%al\t\t#  drive exist? (from BIOS?)\n"
"      jb print_drive\t\t# Yes\n"
"      decw %ax\t\t\t# Already drive 0?\n"
"      jz print_prompt\t\t# Yes\n"
msgstr ""

#. type: Block title
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:274
#, no-wrap
msgid "[.filename]#sys/boot/i386/boot0/boot0.S# [[boot-boot0-test-drives]]"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:276
msgid ""
"We make the assumption that a single drive is present, so the jump to "
"`print_drive` is not performed. We also assume nothing strange happened, so "
"we jump to `print_prompt`."
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:278
msgid ""
"This next block just prints out a prompt followed by the default option:"
msgstr ""
"El siguiente bloque solo imprime un mensaje seguido de la opción "
"predeterminada:"

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:288
#, no-wrap
msgid ""
"print_prompt:\n"
"      movw $prompt,%si\t\t# Display\n"
"      callw putstr\t\t#  prompt\n"
"      movb _OPT(%bp),%dl\t# Display\n"
"      decw %si\t\t\t#  default\n"
"      callw putkey\t\t#  key\n"
"      jmp start_input\t\t# Skip beep\n"
msgstr ""

#. type: Block title
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:290
#, no-wrap
msgid "[.filename]#sys/boot/i386/boot0/boot0.S# [[boot-boot0-prompt]]"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:292
msgid ""
"Finally, a jump is performed to `start_input`, where the BIOS services are "
"used to start a timer and for reading user input from the keyboard; if the "
"timer expires, the default option will be selected:"
msgstr ""

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:308
#, no-wrap
msgid ""
"start_input:\n"
"      xorb %ah,%ah\t\t# BIOS: Get\n"
"      int $0x1a\t\t\t#  system time\n"
"      movw %dx,%di\t\t# Ticks when\n"
"      addw _TICKS(%bp),%di\t#  timeout\n"
"read_key:\n"
"      movb $0x1,%ah\t\t# BIOS: Check\n"
"      int $0x16\t\t\t#  for keypress\n"
"      jnz got_key\t\t# Have input\n"
"      xorb %ah,%ah\t\t# BIOS: int 0x1a, 00\n"
"      int $0x1a\t\t\t#  get system time\n"
"      cmpw %di,%dx\t\t# Timeout?\n"
"      jb read_key\t\t# No\n"
msgstr ""

#. type: Block title
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:310
#, no-wrap
msgid "[.filename]#sys/boot/i386/boot0/boot0.S# [[boot-boot0-start-input]]"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:312
msgid ""
"An interrupt is requested with number `0x1a` and argument `0` in register `"
"%ah`. The BIOS has a predefined set of services, requested by applications "
"as software-generated interrupts through the `int` instruction and receiving "
"arguments in registers (in this case, `%ah`). Here, particularly, we are "
"requesting the number of clock ticks since last midnight; this value is "
"computed by the BIOS through the RTC (Real Time Clock). This clock can be "
"programmed to work at frequencies ranging from 2 Hz to 8192 Hz. The BIOS "
"sets it to 18.2 Hz at startup. When the request is satisfied, a 32-bit "
"result is returned by the BIOS in registers `%cx` and `%dx` (lower bytes in `"
"%dx`). This result (the `%dx` part) is copied to register `%di`, and the "
"value of the `TICKS` variable is added to `%di`. This variable resides in [."
"filename]#boot0# at offset `_TICKS` (a negative value) from register `%bp` "
"(which, recall, points to `0x800`). The default value of this variable is "
"`0xb6` (182 in decimal). Now, the idea is that [.filename]#boot0# constantly "
"requests the time from the BIOS, and when the value returned in register `"
"%dx` is greater than the value stored in `%di`, the time is up and the "
"default selection will be made. Since the RTC ticks 18.2 times per second, "
"this condition will be met after 10 seconds (this default behavior can be "
"changed in the [.filename]#Makefile#). Until this time has passed, [."
"filename]#boot0# continually asks the BIOS for any user input; this is done "
"through `int 0x16`, argument `1` in `%ah`."
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:314
#, fuzzy
msgid ""
"Whether a key was pressed or the time expired, subsequent code validates the "
"selection. Based on the selection, the register `%si` is set to point to the "
"appropriate partition entry in the partition table. This new selection "
"overrides the previous default one. Indeed, it becomes the new default. "
"Finally, the ACTIVE flag of the selected partition is set. If it was enabled "
"at compile time, the in-memory version of [.filename]#boot0# with these "
"modified values is written back to the MBR on disk. We leave the details of "
"this implementation to the reader."
msgstr ""
"Si se presionó una tecla o expiró el tiempo, el código posterior valida la "
"selección. Basado en la selección, el registro <literal>%si</literal> está "
"configurado para apuntar a la entrada de partición apropiada en la tabla de "
"particiones. Esta nueva selección anula la anterior predeterminada. De "
"hecho, se convierte en el nuevo valor predeterminado. Finalmente, se "
"establece el indicador ACTIVO de la partición seleccionada. Si se habilitó "
"en el momento de la compilación, la versión en memoria de <filename>boot0</"
"filename> con estos valores modificados se vuelve a escribir en el "
"<acronym>MBR</acronym> en disco. Dejamos los detalles de esta implementación "
"al lector."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:316
#, fuzzy
msgid ""
"We now end our study with the last code block from the [.filename]#boot0# "
"program:"
msgstr ""
"Ahora terminamos nuestro estudio con el último bloque de código del "
"<filename>boot0</filename> programa:"

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:329
#, no-wrap
msgid ""
"      movw $0x7c00,%bx\t\t# Address for read\n"
"      movb $0x2,%ah\t\t# Read sector\n"
"      callw intx13\t\t#  from disk\n"
"      jc beep\t\t\t# If error\n"
"      cmpw $0xaa55,0x1fe(%bx)\t# Bootable?\n"
"      jne beep\t\t\t# No\n"
"      pushw %si\t\t\t# Save ptr to selected part.\n"
"      callw putn\t\t# Leave some space\n"
"      popw %si\t\t\t# Restore, next stage uses it\n"
"      jmp *%bx\t\t\t# Invoke bootstrap\n"
msgstr ""

#. type: Block title
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:331
#, no-wrap
msgid "[.filename]#sys/boot/i386/boot0/boot0.S# [[boot-boot0-check-bootable]]"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:333
msgid ""
"Recall that `%si` points to the selected partition entry. This entry tells "
"us where the partition begins on disk. We assume, of course, that the "
"partition selected is actually a FreeBSD slice."
msgstr ""

#. type: delimited block = 4
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:337
msgid ""
"From now on, we will favor the use of the technically more accurate term "
"\"slice\" rather than \"partition\"."
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:340
msgid ""
"The transfer buffer is set to `0x7c00` (register `%bx`), and a read for the "
"first sector of the FreeBSD slice is requested by calling `intx13`. We "
"assume that everything went okay, so a jump to `beep` is not performed. In "
"particular, the new sector read must end with the magic sequence `0xaa55`. "
"Finally, the value at `%si` (the pointer to the selected partition table) is "
"preserved for use by the next stage, and a jump is performed to address "
"`0x7c00`, where execution of our next stage (the just-read block) is started."
msgstr ""

#. type: Title ==
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:342
#, no-wrap
msgid "`boot1` Stage"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:345
msgid "So far we have gone through the following sequence:"
msgstr "Hasta ahora hemos pasado por la siguiente secuencia:"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:347
msgid ""
"The BIOS did some early hardware initialization, including the POST. The MBR "
"([.filename]#boot0#) was loaded from absolute disk sector one to address "
"`0x7c00`. Execution control was passed to that location."
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:348
#, fuzzy
msgid ""
"[.filename]#boot0# relocated itself to the location it was linked to execute "
"(`0x600`), followed by a jump to continue execution at the appropriate "
"place. Finally, [.filename]#boot0# loaded the first disk sector from the "
"FreeBSD slice to address `0x7c00`. Execution control was passed to that "
"location."
msgstr ""
"<filename>boot0</filename> se trasladó a la ubicación donde estaba vinculado "
"para ejecutar (<literal>0x600</literal>), seguido de un salto para continuar "
"la ejecución en el lugar apropiado. Finalmente, <filename>boot0</filename> "
"cargó el primer sector del disco desde el segmento FreeBSD a la dirección "
"<literal>0x7c00</literal>.El control de ejecución se pasó a esa ubicación."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:350
msgid ""
"[.filename]#boot1# is the next step in the boot-loading sequence. It is the "
"first of three boot stages. Note that we have been dealing exclusively with "
"disk sectors. Indeed, the BIOS loads the absolute first sector, while [."
"filename]#boot0# loads the first sector of the FreeBSD slice. Both loads are "
"to address `0x7c00`. We can conceptually think of these disk sectors as "
"containing the files [.filename]#boot0# and [.filename]#boot1#, "
"respectively, but in reality this is not entirely true for [."
"filename]#boot1#. Strictly speaking, unlike [.filename]#boot0#, [."
"filename]#boot1# is not part of the boot blocks footnote:[There is a file /"
"boot/boot1, but it is not the written to the beginning of the FreeBSD slice. "
"Instead, it is concatenated with boot2 to form boot, which is written to the "
"beginning of the FreeBSD slice and read at boot time.]. Instead, a single, "
"full-blown file, [.filename]#boot# ([.filename]#/boot/boot#), is what "
"ultimately is written to disk. This file is a combination of [."
"filename]#boot1#, [.filename]#boot2# and the `Boot Extender` (or BTX). This "
"single file is greater in size than a single sector (greater than 512 "
"bytes). Fortunately, [.filename]#boot1# occupies _exactly_ the first 512 "
"bytes of this single file, so when [.filename]#boot0# loads the first sector "
"of the FreeBSD slice (512 bytes), it is actually loading [.filename]#boot1# "
"and transferring control to it."
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:352
msgid ""
"The main task of [.filename]#boot1# is to load the next boot stage. This "
"next stage is somewhat more complex. It is composed of a server called the "
"\"Boot Extender\", or BTX, and a client, called [.filename]#boot2#. As we "
"will see, the last boot stage, [.filename]#loader#, is also a client of the "
"BTX server."
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:354
#, fuzzy
msgid ""
"Let us now look in detail at what exactly is done by [.filename]#boot1#, "
"starting like we did for [.filename]#boot0#, at its entry point:"
msgstr ""
"Veamos ahora en detalle lo que hace exactamente <filename>boot1</filename>, "
"comenzando como lo hicimos para <filename>boot0</filename>, en su punto de "
"entrada:"

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:359
#, no-wrap
msgid ""
"start:\n"
"\tjmp main\n"
msgstr ""

#. type: Block title
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:361
#, no-wrap
msgid "[.filename]#sys/boot/i386/boot2/boot1.S# [[boot-boot1-entry]]"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:363
msgid ""
"The entry point at `start` simply jumps past a special data area to the "
"label `main`, which in turn looks like this:"
msgstr ""

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:378
#, no-wrap
msgid ""
"main:\n"
"      cld\t\t\t# String ops inc\n"
"      xor %cx,%cx\t\t# Zero\n"
"      mov %cx,%es\t\t# Address\n"
"      mov %cx,%ds\t\t#  data\n"
"      mov %cx,%ss\t\t# Set up\n"
"      mov $start,%sp\t\t#  stack\n"
"      mov %sp,%si\t\t# Source\n"
"      mov $0x700,%di\t\t# Destination\n"
"      incb %ch\t\t\t# Word count\n"
"      rep\t\t\t# Copy\n"
"      movsw\t\t\t#  code\n"
msgstr ""

#. type: Block title
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:380
#, no-wrap
msgid "[.filename]#sys/boot/i386/boot2/boot1.S# [[boot-boot1-main]]"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:382
msgid ""
"Just like [.filename]#boot0#, this code relocates [.filename]#boot1#, this "
"time to memory address `0x700`. However, unlike [.filename]#boot0#, it does "
"not jump there. [.filename]#boot1# is linked to execute at address `0x7c00`, "
"effectively where it was loaded in the first place. The reason for this "
"relocation will be discussed shortly."
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:384
msgid ""
"Next comes a loop that looks for the FreeBSD slice. Although [."
"filename]#boot0# loaded [.filename]#boot1# from the FreeBSD slice, no "
"information was passed to it about this footnote:[Actually we did pass a "
"pointer to the slice entry in register %si. However, boot1 does not assume "
"that it was loaded by boot0 (perhaps some other MBR loaded it, and did not "
"pass this information), so it assumes nothing.], so [.filename]#boot1# must "
"rescan the partition table to find where the FreeBSD slice starts. Therefore "
"it rereads the MBR:"
msgstr ""

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:392
#, no-wrap
msgid ""
"      mov $part4,%si\t\t# Partition\n"
"      cmpb $0x80,%dl\t\t# Hard drive?\n"
"      jb main.4\t\t\t# No\n"
"      movb $0x1,%dh\t\t# Block count\n"
"      callw nread\t\t# Read MBR\n"
msgstr ""

#. type: Block title
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:394
#, no-wrap
msgid "[.filename]#sys/boot/i386/boot2/boot1.S# [[boot-boot1-find-freebsd]]"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:396
msgid ""
"In the code above, register `%dl` maintains information about the boot "
"device. This is passed on by the BIOS and preserved by the MBR. Numbers "
"`0x80` and greater tells us that we are dealing with a hard drive, so a call "
"is made to `nread`, where the MBR is read. Arguments to `nread` are passed "
"through `%si` and `%dh`. The memory address at label `part4` is copied to `"
"%si`. This memory address holds a \"fake partition\" to be used by `nread`. "
"The following is the data in the fake partition:"
msgstr ""

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:404
#, no-wrap
msgid ""
"      part4:\n"
"\t.byte 0x80, 0x00, 0x01, 0x00\n"
"\t.byte 0xa5, 0xfe, 0xff, 0xff\n"
"\t.byte 0x00, 0x00, 0x00, 0x00\n"
"\t.byte 0x50, 0xc3, 0x00, 0x00\n"
msgstr ""

#. type: Block title
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:406
#, no-wrap
msgid "[.filename]#sys/boot/i386/boot2/Makefile# [[boot-boot2-make-fake-partition]]"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:408
#, fuzzy
msgid ""
"In particular, the LBA for this fake partition is hardcoded to zero. This is "
"used as an argument to the BIOS for reading absolute sector one from the "
"hard drive. Alternatively, CHS addressing could be used. In this case, the "
"fake partition holds cylinder 0, head 0 and sector 1, which is equivalent to "
"absolute sector one."
msgstr ""
"En particular, el <acronym>LBA</acronym> porque esta partición falsa está "
"codificada a cero. Esto se utiliza como argumento para <acronym>BIOS</"
"acronym> para leer el sector absoluto uno del disco duro. Alternativamente, "
"se podría utilizar el direccionamiento CHS. En este caso, la partición falsa "
"contiene el cilindro 0, la cabeza 0 y el sector 1, que es equivalente al "
"sector uno absoluto."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:410
msgid "Let us now proceed to take a look at `nread`:"
msgstr ""

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:420
#, no-wrap
msgid ""
"nread:\n"
"      mov $0x8c00,%bx\t\t# Transfer buffer\n"
"      mov 0x8(%si),%ax\t\t# Get\n"
"      mov 0xa(%si),%cx\t\t#  LBA\n"
"      push %cs\t\t\t# Read from\n"
"      callw xread.1\t\t#  disk\n"
"      jnc return\t\t# If success, return\n"
msgstr ""

#. type: Block title
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:422
#, no-wrap
msgid "[.filename]#sys/boot/i386/boot2/boot1.S# [[boot-boot1-nread]]"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:424
msgid ""
"Recall that `%si` points to the fake partition. The word footnote:[In the "
"context of 16-bit real mode, a word is 2 bytes.] at offset `0x8` is copied "
"to register `%ax` and word at offset `0xa` to `%cx`. They are interpreted by "
"the BIOS as the lower 4-byte value denoting the LBA to be read (the upper "
"four bytes are assumed to be zero). Register `%bx` holds the memory address "
"where the MBR will be loaded. The instruction pushing `%cs` onto the stack "
"is very interesting. In this context, it accomplishes nothing. However, as "
"we will see shortly, [.filename]#boot2#, in conjunction with the BTX server, "
"also uses `xread.1`. This mechanism will be discussed in the next section."
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:426
msgid ""
"The code at `xread.1` further calls the `read` function, which actually "
"calls the BIOS asking for the disk sector:"
msgstr ""

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:443
#, no-wrap
msgid ""
"xread.1:\n"
"\tpushl $0x0\t\t#  absolute\n"
"\tpush %cx\t\t#  block\n"
"\tpush %ax\t\t#  number\n"
"\tpush %es\t\t# Address of\n"
"\tpush %bx\t\t#  transfer buffer\n"
"\txor %ax,%ax\t\t# Number of\n"
"\tmovb %dh,%al\t\t#  blocks to\n"
"\tpush %ax\t\t#  transfer\n"
"\tpush $0x10\t\t# Size of packet\n"
"\tmov %sp,%bp\t\t# Packet pointer\n"
"\tcallw read\t\t# Read from disk\n"
"\tlea 0x10(%bp),%sp\t# Clear stack\n"
"\tlret\t\t\t# To far caller\n"
msgstr ""

#. type: Block title
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:445
#, no-wrap
msgid "[.filename]#sys/boot/i386/boot2/boot1.S# [[boot-boot1-xread1]]"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:447
msgid ""
"Note the long return instruction at the end of this block. This instruction "
"pops out the `%cs` register pushed by `nread`, and returns. Finally, `nread` "
"also returns."
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:449
msgid ""
"With the MBR loaded to memory, the actual loop for searching the FreeBSD "
"slice begins:"
msgstr ""

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:469
#, no-wrap
msgid ""
"\tmov $0x1,%cx\t\t # Two passes\n"
"main.1:\n"
"\tmov $0x8dbe,%si # Partition table\n"
"\tmovb $0x1,%dh\t\t # Partition\n"
"main.2:\n"
"\tcmpb $0xa5,0x4(%si)\t # Our partition type?\n"
"\tjne main.3\t\t # No\n"
"\tjcxz main.5\t\t # If second pass\n"
"\ttestb $0x80,(%si)\t # Active?\n"
"\tjnz main.5\t\t # Yes\n"
"main.3:\n"
"\tadd $0x10,%si\t\t # Next entry\n"
"\tincb %dh\t\t # Partition\n"
"\tcmpb $0x5,%dh\t\t # In table?\n"
"\tjb main.2\t\t # Yes\n"
"\tdec %cx\t\t\t # Do two\n"
"\tjcxz main.1\t\t #  passes\n"
msgstr ""

#. type: Block title
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:471
#, no-wrap
msgid "[.filename]#sys/boot/i386/boot2/boot1.S# [[boot-boot1-find-part]]"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:473
msgid ""
"If a FreeBSD slice is identified, execution continues at `main.5`. Note that "
"when a FreeBSD slice is found `%si` points to the appropriate entry in the "
"partition table, and `%dh` holds the partition number. We assume that a "
"FreeBSD slice is found, so we continue execution at `main.5`:"
msgstr ""

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:488
#, no-wrap
msgid ""
"main.5:\n"
"\tmov %dx,0x900\t\t\t   # Save args\n"
"\tmovb $0x10,%dh\t\t\t   # Sector count\n"
"\tcallw nread\t\t\t   # Read disk\n"
"\tmov $0x9000,%bx\t\t\t   # BTX\n"
"\tmov 0xa(%bx),%si\t\t   # Get BTX length and set\n"
"\tadd %bx,%si\t\t\t   #  %si to start of boot2.bin\n"
"\tmov $0xc000,%di\t\t\t   # Client page 2\n"
"\tmov $0xa200,%cx\t\t\t   # Byte\n"
"\tsub %si,%cx\t\t\t   #  count\n"
"\trep\t\t\t\t   # Relocate\n"
"\tmovsb\t\t\t\t   #  client\n"
msgstr ""

#. type: Block title
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:490
#, no-wrap
msgid "[.filename]#sys/boot/i386/boot2/boot1.S# [[boot-boot1-main5]]"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:492
msgid ""
"Recall that at this point, register `%si` points to the FreeBSD slice entry "
"in the MBR partition table, so a call to `nread` will effectively read "
"sectors at the beginning of this partition. The argument passed on register `"
"%dh` tells `nread` to read 16 disk sectors. Recall that the first 512 bytes, "
"or the first sector of the FreeBSD slice, coincides with the [."
"filename]#boot1# program. Also recall that the file written to the beginning "
"of the FreeBSD slice is not [.filename]#/boot/boot1#, but [.filename]#/boot/"
"boot#. Let us look at the size of these files in the filesystem:"
msgstr ""

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:499
#, no-wrap
msgid ""
"-r--r--r--  1 root  wheel   512B Jan  8 00:15 /boot/boot0\n"
"-r--r--r--  1 root  wheel   512B Jan  8 00:15 /boot/boot1\n"
"-r--r--r--  1 root  wheel   7.5K Jan  8 00:15 /boot/boot2\n"
"-r--r--r--  1 root  wheel   8.0K Jan  8 00:15 /boot/boot\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:502
msgid ""
"Both [.filename]#boot0# and [.filename]#boot1# are 512 bytes each, so they "
"fit _exactly_ in one disk sector. [.filename]#boot2# is much bigger, holding "
"both the BTX server and the [.filename]#boot2# client. Finally, a file "
"called simply [.filename]#boot# is 512 bytes larger than [.filename]#boot2#. "
"This file is a concatenation of [.filename]#boot1# and [.filename]#boot2#. "
"As already noted, [.filename]#boot0# is the file written to the absolute "
"first disk sector (the MBR), and [.filename]#boot# is the file written to "
"the first sector of the FreeBSD slice; [.filename]#boot1# and [."
"filename]#boot2# are _not_ written to disk. The command used to concatenate "
"[.filename]#boot1# and [.filename]#boot2# into a single [.filename]#boot# is "
"merely `cat boot1 boot2 > boot`."
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:504
msgid ""
"So [.filename]#boot1# occupies exactly the first 512 bytes of [."
"filename]#boot# and, because [.filename]#boot# is written to the first "
"sector of the FreeBSD slice, [.filename]#boot1# fits exactly in this first "
"sector. When `nread` reads the first 16 sectors of the FreeBSD slice, it "
"effectively reads the entire [.filename]#boot# file footnote:[512*16=8192 "
"bytes, exactly the size of boot]. We will see more details about how [."
"filename]#boot# is formed from [.filename]#boot1# and [.filename]#boot2# in "
"the next section."
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:506
msgid ""
"Recall that `nread` uses memory address `0x8c00` as the transfer buffer to "
"hold the sectors read. This address is conveniently chosen. Indeed, because "
"[.filename]#boot1# belongs to the first 512 bytes, it ends up in the address "
"range `0x8c00`-`0x8dff`. The 512 bytes that follows (range `0x8e00`-"
"`0x8fff`) is used to store the _bsdlabel_ footnote:[Historically known as "
"disklabel. If you ever wondered where FreeBSD stored this information, it is "
"in this region. See man:bsdlabel[8]]."
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:508
msgid ""
"Starting at address `0x9000` is the beginning of the BTX server, and "
"immediately following is the [.filename]#boot2# client. The BTX server acts "
"as a kernel, and executes in protected mode in the most privileged level. In "
"contrast, the BTX clients ([.filename]#boot2#, for example), execute in user "
"mode. We will see how this is accomplished in the next section. The code "
"after the call to `nread` locates the beginning of [.filename]#boot2# in the "
"memory buffer, and copies it to memory address `0xc000`. This is because the "
"BTX server arranges [.filename]#boot2# to execute in a segment starting at "
"`0xa000`. We explore this in detail in the following section."
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:510
msgid ""
"The last code block of [.filename]#boot1# enables access to memory above 1MB "
"footnote:[This is necessary for legacy reasons. Interested readers should "
"see .] and concludes with a jump to the starting point of the BTX server:"
msgstr ""

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:518
#, no-wrap
msgid ""
"seta20:\n"
"\tcli\t\t\t# Disable interrupts\n"
"seta20.1:\n"
"\tdec %cx\t\t\t# Timeout?\n"
"\tjz seta20.3\t\t# Yes\n"
msgstr ""

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:533
#, no-wrap
msgid ""
"\tinb $0x64,%al\t\t# Get status\n"
"\ttestb $0x2,%al\t\t# Busy?\n"
"\tjnz seta20.1\t\t# Yes\n"
"\tmovb $0xd1,%al\t\t# Command: Write\n"
"\toutb %al,$0x64\t\t#  output port\n"
"seta20.2:\n"
"\tinb $0x64,%al\t\t# Get status\n"
"\ttestb $0x2,%al\t\t# Busy?\n"
"\tjnz seta20.2\t\t# Yes\n"
"\tmovb $0xdf,%al\t\t# Enable\n"
"\toutb %al,$0x60\t\t#  A20\n"
"seta20.3:\n"
"\tsti\t\t\t# Enable interrupts\n"
"\tjmp 0x9010\t\t# Start BTX\n"
msgstr ""

#. type: Block title
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:535
#, no-wrap
msgid "[.filename]#sys/boot/i386/boot2/boot1.S# [[boot-boot1-seta20]]"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:537
msgid "Note that right before the jump, interrupts are enabled."
msgstr ""
"Tenga en cuenta que justo antes del salto, las interrupciones están "
"habilitadas."

#. type: Title ==
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:539
#, no-wrap
msgid "The BTX Server"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:542
msgid ""
"Next in our boot sequence is the BTX Server. Let us quickly remember how we "
"got here:"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:544
msgid ""
"The BIOS loads the absolute sector one (the MBR, or [.filename]#boot0#), to "
"address `0x7c00` and jumps there."
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:545
msgid ""
"[.filename]#boot0# relocates itself to `0x600`, the address it was linked to "
"execute, and jumps over there. It then reads the first sector of the FreeBSD "
"slice (which consists of [.filename]#boot1#) into address `0x7c00` and jumps "
"over there."
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:546
msgid ""
"[.filename]#boot1# loads the first 16 sectors of the FreeBSD slice into "
"address `0x8c00`. This 16 sectors, or 8192 bytes, is the whole file [."
"filename]#boot#. The file is a concatenation of [.filename]#boot1# and [."
"filename]#boot2#. [.filename]#boot2#, in turn, contains the BTX server and "
"the [.filename]#boot2# client. Finally, a jump is made to address `0x9010`, "
"the entry point of the BTX server."
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:548
msgid ""
"Before studying the BTX Server in detail, let us further review how the "
"single, all-in-one [.filename]#boot# file is created. The way [."
"filename]#boot# is built is defined in its [.filename]#Makefile# ([."
"filename]#/usr/src/sys/boot/i386/boot2/Makefile#). Let us look at the rule "
"that creates the [.filename]#boot# file:"
msgstr ""

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:553
#, no-wrap
msgid ""
"      boot: boot1 boot2\n"
"\tcat boot1 boot2 > boot\n"
msgstr ""

#. type: Block title
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:555
#, no-wrap
msgid "[.filename]#sys/boot/i386/boot2/Makefile# [[boot-boot1-make-boot]]"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:557
msgid ""
"This tells us that [.filename]#boot1# and [.filename]#boot2# are needed, and "
"the rule simply concatenates them to produce a single file called [."
"filename]#boot#. The rules for creating [.filename]#boot1# are also quite "
"simple:"
msgstr ""

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:562
#, no-wrap
msgid ""
"      boot1: boot1.out\n"
"\tobjcopy -S -O binary boot1.out boot1\n"
msgstr ""

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:565
#, no-wrap
msgid ""
"      boot1.out: boot1.o\n"
"\tld -e start -Ttext 0x7c00 -o boot1.out boot1.o\n"
msgstr ""

#. type: Block title
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:567
#, no-wrap
msgid "[.filename]#sys/boot/i386/boot2/Makefile# [[boot-boot1-make-boot1]]"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:569
msgid ""
"To apply the rule for creating [.filename]#boot1#, [.filename]#boot1.out# "
"must be resolved. This, in turn, depends on the existence of [."
"filename]#boot1.o#. This last file is simply the result of assembling our "
"familiar [.filename]#boot1.S#, without linking. Now, the rule for creating [."
"filename]#boot1.out# is applied. This tells us that [.filename]#boot1.o# "
"should be linked with `start` as its entry point, and starting at address "
"`0x7c00`. Finally, [.filename]#boot1# is created from [.filename]#boot1.out# "
"applying the appropriate rule. This rule is the [.filename]#objcopy# command "
"applied to [.filename]#boot1.out#. Note the flags passed to [."
"filename]#objcopy#: `-S` tells it to strip all relocation and symbolic "
"information; `-O binary` indicates the output format, that is, a simple, "
"unformatted binary file."
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:571
msgid ""
"Having [.filename]#boot1#, let us take a look at how [.filename]#boot2# is "
"constructed:"
msgstr ""

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:578
#, no-wrap
msgid ""
"      boot2: boot2.ld\n"
"\t@set -- `ls -l boot2.ld`; x=$$((7680-$$5)); \\\n"
"\t    echo \"$$x bytes available\"; test $$x -ge 0\n"
"\tdd if=boot2.ld of=boot2 obs=7680 conv=osync\n"
msgstr ""

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:582
#, no-wrap
msgid ""
"      boot2.ld: boot2.ldr boot2.bin ../btx/btx/btx\n"
"\tbtxld -v -E 0x2000 -f bin -b ../btx/btx/btx -l boot2.ldr \\\n"
"\t    -o boot2.ld -P 1 boot2.bin\n"
msgstr ""

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:585
#, no-wrap
msgid ""
"      boot2.ldr:\n"
"\tdd if=/dev/zero of=boot2.ldr bs=512 count=1\n"
msgstr ""

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:588
#, no-wrap
msgid ""
"      boot2.bin: boot2.out\n"
"\tobjcopy -S -O binary boot2.out boot2.bin\n"
msgstr ""

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:591
#, no-wrap
msgid ""
"      boot2.out: ../btx/lib/crt0.o boot2.o sio.o\n"
"\tld -Ttext 0x2000 -o boot2.out\n"
msgstr ""

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:594
#, no-wrap
msgid ""
"      boot2.o: boot2.s\n"
"\t${CC} ${ACFLAGS} -c boot2.s\n"
msgstr ""

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:599
#, no-wrap
msgid ""
"      boot2.s: boot2.c boot2.h ${.CURDIR}/../../common/ufsread.c\n"
"\t${CC} ${CFLAGS} -S -o boot2.s.tmp ${.CURDIR}/boot2.c\n"
"\tsed -e '/align/d' -e '/nop/d' \"MISSING\" boot2.s.tmp > boot2.s\n"
"\trm -f boot2.s.tmp\n"
msgstr ""

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:606
#, no-wrap
msgid ""
"      boot2.h: boot1.out\n"
"\t${NM} -t d ${.ALLSRC} | awk '/([0-9])+ T xread/ \\\n"
"\t    { x = $$1 - ORG1; \\\n"
"\t    printf(\"#define XREADORG %#x\\n\", REL1 + x) }' \\\n"
"\t    ORG1=`printf \"%d\" ${ORG1}` \\\n"
"\t    REL1=`printf \"%d\" ${REL1}` > ${.TARGET}\n"
msgstr ""

#. type: Block title
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:608
#, no-wrap
msgid "[.filename]#sys/boot/i386/boot2/Makefile# [[boot-boot1-make-boot2]]"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:610
#, fuzzy
msgid ""
"The mechanism for building [.filename]#boot2# is far more elaborate. Let us "
"point out the most relevant facts. The dependency list is as follows:"
msgstr ""
"El mecanismo de construcción <filename>boot2</filename> es mucho más "
"elaborado. Señalemos los hechos más relevantes. La lista de dependencias es "
"la siguiente:"

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:620
#, no-wrap
msgid ""
"      boot2: boot2.ld\n"
"      boot2.ld: boot2.ldr boot2.bin ${BTXDIR}/btx/btx\n"
"      boot2.bin: boot2.out\n"
"      boot2.out: ${BTXDIR}/lib/crt0.o boot2.o sio.o\n"
"      boot2.o: boot2.s\n"
"      boot2.s: boot2.c boot2.h ${.CURDIR}/../../common/ufsread.c\n"
"      boot2.h: boot1.out\n"
msgstr ""

#. type: Block title
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:622
#, no-wrap
msgid "[.filename]#sys/boot/i386/boot2/Makefile# [[boot-boot1-make-boot2-more]]"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:624
#, fuzzy
msgid ""
"Note that initially there is no header file [.filename]#boot2.h#, but its "
"creation depends on [.filename]#boot1.out#, which we already have. The rule "
"for its creation is a bit terse, but the important thing is that the output, "
"[.filename]#boot2.h#, is something like this:"
msgstr ""
"Tenga en cuenta que inicialmente no hay un archivo de encabezado "
"<filename>boot2.h</filename>, pero su creación depende de<filename>boot1."
"out</filename>, que ya tenemos. La regla para su creación es un poco "
"concisa, pero lo importante es que la salida, <filename>boot2.h</filename>, "
"es algo como esto:"

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:628
#, no-wrap
msgid "#define XREADORG 0x725\n"
msgstr ""

#. type: Block title
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:630
#, no-wrap
msgid "[.filename]#sys/boot/i386/boot2/boot2.h# [[boot-boot1-make-boot2h]]"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:632
msgid ""
"Recall that [.filename]#boot1# was relocated (i.e., copied from `0x7c00` to "
"`0x700`). This relocation will now make sense, because as we will see, the "
"BTX server reclaims some memory, including the space where [."
"filename]#boot1# was originally loaded. However, the BTX server needs access "
"to [.filename]#boot1#'s `xread` function; this function, according to the "
"output of [.filename]#boot2.h#, is at location `0x725`. Indeed, the BTX "
"server uses the `xread` function from [.filename]#boot1#'s relocated code. "
"This function is now accessible from within the [.filename]#boot2# client."
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:634
msgid ""
"We next build [.filename]#boot2.s# from files [.filename]#boot2.h#, [."
"filename]#boot2.c# and [.filename]#/usr/src/sys/boot/common/ufsread.c#. The "
"rule for this is to compile the code in [.filename]#boot2.c# (which includes "
"[.filename]#boot2.h# and [.filename]#ufsread.c#) into assembly code. Having "
"[.filename]#boot2.s#, the next rule assembles [.filename]#boot2.s#, creating "
"the object file [.filename]#boot2.o#. The next rule directs the linker to "
"link various files ([.filename]#crt0.o#, [.filename]#boot2.o# and [."
"filename]#sio.o#). Note that the output file, [.filename]#boot2.out#, is "
"linked to execute at address `0x2000`. Recall that [.filename]#boot2# will "
"be executed in user mode, within a special user segment set up by the BTX "
"server. This segment starts at `0xa000`. Also, remember that the [."
"filename]#boot2# portion of [.filename]#boot# was copied to address "
"`0xc000`, that is, offset `0x2000` from the start of the user segment, so [."
"filename]#boot2# will work properly when we transfer control to it. Next, [."
"filename]#boot2.bin# is created from [.filename]#boot2.out# by stripping its "
"symbols and format information; boot2.bin is a _raw_ binary. Now, note that "
"a file [.filename]#boot2.ldr# is created as a 512-byte file full of zeros. "
"This space is reserved for the bsdlabel."
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:636
msgid ""
"Now that we have files [.filename]#boot1#, [.filename]#boot2.bin# and [."
"filename]#boot2.ldr#, only the BTX server is missing before creating the all-"
"in-one [.filename]#boot# file. The BTX server is located in [.filename]#/usr/"
"src/sys/boot/i386/btx/btx#; it has its own [.filename]#Makefile# with its "
"own set of rules for building. The important thing to notice is that it is "
"also compiled as a _raw_ binary, and that it is linked to execute at address "
"`0x9000`. The details can be found in [.filename]#/usr/src/sys/boot/i386/btx/"
"btx/Makefile#."
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:638
msgid ""
"Having the files that comprise the [.filename]#boot# program, the final step "
"is to _merge_ them. This is done by a special program called [."
"filename]#btxld# (source located in [.filename]#/usr/src/usr.sbin/btxld#). "
"Some arguments to this program include the name of the output file ([."
"filename]#boot#), its entry point (`0x2000`) and its file format (raw "
"binary). The various files are finally merged by this utility into the file "
"[.filename]#boot#, which consists of [.filename]#boot1#, [.filename]#boot2#, "
"the `bsdlabel` and the BTX server. This file, which takes exactly 16 "
"sectors, or 8192 bytes, is what is actually written to the beginning of the "
"FreeBSD slice during installation. Let us now proceed to study the BTX "
"server program."
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:640
#, fuzzy
msgid ""
"The BTX server prepares a simple environment and switches from 16-bit real "
"mode to 32-bit protected mode, right before passing control to the client. "
"This includes initializing and updating the following data structures:"
msgstr ""
"El <acronym>BTX</acronym> El servidor prepara un entorno simple y cambia del "
"modo real de 16 bits al modo protegido de 32 bits, justo antes de pasar el "
"control al cliente. Esto incluye inicializar y actualizar las siguientes "
"estructuras de datos:"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:642
msgid ""
"Modifies the `Interrupt Vector Table (IVT)`. The IVT provides exception and "
"interrupt handlers for Real-Mode code."
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:643
#, fuzzy
msgid ""
"The `Interrupt Descriptor Table (IDT)` is created. Entries are provided for "
"processor exceptions, hardware interrupts, two system calls and V86 "
"interface. The IDT provides exception and interrupt handlers for Protected-"
"Mode code."
msgstr ""
"El <literal>Tabla de descriptores de interrupciones (IDT)</literal> es "
"creado. Se proporcionan entradas para excepciones de procesador, "
"interrupciones de hardware, dos llamadas al sistema e interfaz V86. El IDT "
"proporciona manejadores de excepciones e interrupciones para el código en "
"modo protegido."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:644
msgid ""
"A `Task-State Segment (TSS)` is created. This is necessary because the "
"processor works in the _least_ privileged level when executing the client ([."
"filename]#boot2#), but in the _most_ privileged level when executing the BTX "
"server."
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:645
msgid ""
"The GDT (Global Descriptor Table) is set up. Entries (descriptors) are "
"provided for supervisor code and data, user code and data, and real-mode "
"code and data. footnote:[Real-mode code and data are necessary when "
"switching back to real mode from protected mode, as suggested by the Intel "
"manuals.]"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:647
msgid ""
"Let us now start studying the actual implementation. Recall that [."
"filename]#boot1# made a jump to address `0x9010`, the BTX server's entry "
"point. Before studying program execution there, note that the BTX server has "
"a special header at address range `0x9000-0x900f`, right before its entry "
"point. This header is defined as follows:"
msgstr ""

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:663
#, no-wrap
msgid ""
"start:\t\t\t\t\t\t# Start of code\n"
"/*\n"
" * BTX header.\n"
" */\n"
"btx_hdr:\t.byte 0xeb\t\t\t# Machine ID\n"
"\t\t.byte 0xe\t\t\t# Header size\n"
"\t\t.ascii \"BTX\"\t\t\t# Magic\n"
"\t\t.byte 0x1\t\t\t# Major version\n"
"\t\t.byte 0x2\t\t\t# Minor version\n"
"\t\t.byte BTX_FLAGS\t\t\t# Flags\n"
"\t\t.word PAG_CNT-MEM_ORG>>0xc\t# Paging control\n"
"\t\t.word break-start\t\t# Text size\n"
"\t\t.long 0x0\t\t\t# Entry address\n"
msgstr ""

#. type: Block title
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:665
#, no-wrap
msgid "[.filename]#sys/boot/i386/btx/btx/btx.S# [[btx-header]]"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:667
msgid ""
"Note the first two bytes are `0xeb` and `0xe`. In the IA-32 architecture, "
"these two bytes are interpreted as a relative jump past the header into the "
"entry point, so in theory, [.filename]#boot1# could jump here (address "
"`0x9000`) instead of address `0x9010`. Note that the last field in the BTX "
"header is a pointer to the client's ([.filename]#boot2#) entry point. This "
"field is patched at link time."
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:669
msgid "Immediately following the header is the BTX server's entry point:"
msgstr ""

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:683
#, no-wrap
msgid ""
"/*\n"
" * Initialization routine.\n"
" */\n"
"init:\t\tcli\t\t\t\t# Disable interrupts\n"
"\t\txor %ax,%ax\t\t\t# Zero/segment\n"
"\t\tmov %ax,%ss\t\t\t# Set up\n"
"\t\tmov $0x1800,%sp\t\t#  stack\n"
"\t\tmov %ax,%es\t\t\t# Address\n"
"\t\tmov %ax,%ds\t\t\t#  data\n"
"\t\tpushl $0x2\t\t\t# Clear\n"
"\t\tpopfl\t\t\t\t#  flags\n"
msgstr ""

#. type: Block title
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:685
#, no-wrap
msgid "[.filename]#sys/boot/i386/btx/btx/btx.S# [[btx-init]]"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:687
msgid ""
"This code disables interrupts, sets up a working stack (starting at address "
"`0x1800`) and clears the flags in the EFLAGS register. Note that the `popfl` "
"instruction pops out a doubleword (4 bytes) from the stack and places it in "
"the EFLAGS register. As the value actually popped is `2`, the EFLAGS "
"register is effectively cleared (IA-32 requires that bit 2 of the EFLAGS "
"register always be 1)."
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:689
msgid ""
"Our next code block clears (sets to `0`) the memory range `0x5e00-0x8fff`. "
"This range is where the various data structures will be created:"
msgstr ""

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:699
#, no-wrap
msgid ""
"/*\n"
" * Initialize memory.\n"
" */\n"
"\t\tmov $0x5e00,%di\t\t# Memory to initialize\n"
"\t\tmov $(0x9000-0x5e00)/2,%cx\t# Words to zero\n"
"\t\trep\t\t\t\t# Zero-fill\n"
"\t\tstosw\t\t\t\t#  memory\n"
msgstr ""

#. type: Block title
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:701
#, no-wrap
msgid "[.filename]#sys/boot/i386/btx/btx/btx.S# [[btx-clear-mem]]"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:703
msgid ""
"Recall that [.filename]#boot1# was originally loaded to address `0x7c00`, "
"so, with this memory initialization, that copy effectively disappeared. "
"However, also recall that [.filename]#boot1# was relocated to `0x700`, so "
"_that_ copy is still in memory, and the BTX server will make use of it."
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:705
msgid ""
"Next, the real-mode IVT (Interrupt Vector Table is updated. The IVT is an "
"array of segment/offset pairs for exception and interrupt handlers. The BIOS "
"normally maps hardware interrupts to interrupt vectors `0x8` to `0xf` and "
"`0x70` to `0x77` but, as will be seen, the 8259A Programmable Interrupt "
"Controller, the chip controlling the actual mapping of hardware interrupts "
"to interrupt vectors, is programmed to remap these interrupt vectors from "
"`0x8-0xf` to `0x20-0x27` and from `0x70-0x77` to `0x28-0x2f`. Thus, "
"interrupt handlers are provided for interrupt vectors `0x20-0x2f`. The "
"reason the BIOS-provided handlers are not used directly is because they work "
"in 16-bit real mode, but not 32-bit protected mode. Processor mode will be "
"switched to 32-bit protected mode shortly. However, the BTX server sets up a "
"mechanism to effectively use the handlers provided by the BIOS:"
msgstr ""

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:720
#, fuzzy, no-wrap
msgid ""
"/*\n"
" * Update real mode IDT for reflecting hardware interrupts.\n"
" */\n"
"\t\tmov $intr20,%bx\t\t\t# Address first handler\n"
"\t\tmov $0x10,%cx\t\t\t# Number of handlers\n"
"\t\tmov $0x20*4,%di\t\t\t# First real mode IDT entry\n"
"init.0:\t\tmov %bx,(%di)\t\t\t# Store IP\n"
"\t\tinc %di\t\t\t\t# Address next\n"
"\t\tinc %di\t\t\t\t#  entry\n"
"\t\tstosw\t\t\t\t# Store CS\n"
"\t\tadd $4,%bx\t\t\t# Next handler\n"
"\t\tloop init.0\t\t\t# Next IRQ\n"
msgstr ""
"/*\n"
" * Actualice el IDT en modo real para reflejar las interrupciones de "
"hardware.\n"
" */\n"
"\t\tmov $intr20,%bx\t\t\t# Dirección del primer manejador\n"
"\t\tmov $0x10,%cx\t\t\t# Número de manipuladores\n"
"\t\tmov $0x20*4,%di\t\t\t# Primera entrada IDT en modo real\n"
"init.0:\t\tmov %bx,(%di)\t\t\t# IP de la tienda\n"
"\t\tinc %di\t\t\t\t# Dirección siguiente\n"
"\t\tinc %di\t\t\t\t#  entrada\n"
"\t\tstosw\t\t\t\t#  Almacenar CS\n"
"\t\tadd $4,%bx\t\t\t# Siguiente controlador\n"
"\t\tloop init.0\t\t\t# Next IRQ\n"

#. type: Block title
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:722
#, no-wrap
msgid "[.filename]#sys/boot/i386/btx/btx/btx.S# [[btx-ivt]]"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:724
#, fuzzy
msgid ""
"The next block creates the IDT (Interrupt Descriptor Table). The IDT is "
"analogous, in protected mode, to the IVT in real mode. That is, the IDT "
"describes the various exception and interrupt handlers used when the "
"processor is executing in protected mode. In essence, it also consists of an "
"array of segment/offset pairs, although the structure is somewhat more "
"complex, because segments in protected mode are different than in real mode, "
"and various protection mechanisms apply:"
msgstr ""
"El siguiente bloque crea el <acronym>IDT</acronym> (Tabla de descriptores de "
"interrupciones). los <acronym>IDT</acronym> es análogo, en modo protegido, "
"al <acronym>IVT</acronym> en modo real. Eso es el <acronym>IDT</acronym> "
"describe los diversos manejadores de excepciones e interrupciones que se "
"utilizan cuando el procesador se ejecuta en modo protegido. En esencia, "
"también consta de una matriz de pares de segmento / desplazamiento, aunque "
"la estructura es algo más compleja, porque los segmentos en modo protegido "
"son diferentes a los del modo real, y se aplican varios mecanismos de "
"protección:"

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:751
#, fuzzy, no-wrap
msgid ""
"/*\n"
" * Create IDT.\n"
" */\n"
"\t\tmov $0x5e00,%di\t\t\t# IDT's address\n"
"\t\tmov $idtctl,%si\t\t\t# Control string\n"
"init.1:\t\tlodsb\t\t\t\t# Get entry\n"
"\t\tcbw\t\t\t\t#  count\n"
"\t\txchg %ax,%cx\t\t\t#  as word\n"
"\t\tjcxz init.4\t\t\t# If done\n"
"\t\tlodsb\t\t\t\t# Get segment\n"
"\t\txchg %ax,%dx\t\t\t#  P:DPL:type\n"
"\t\tlodsw\t\t\t\t# Get control\n"
"\t\txchg %ax,%bx\t\t\t#  set\n"
"\t\tlodsw\t\t\t\t# Get handler offset\n"
"\t\tmov $SEL_SCODE,%dh\t\t# Segment selector\n"
"init.2:\t\tshr %bx\t\t\t\t# Handle this int?\n"
"\t\tjnc init.3\t\t\t# No\n"
"\t\tmov %ax,(%di)\t\t\t# Set handler offset\n"
"\t\tmov %dh,0x2(%di)\t\t#  and selector\n"
"\t\tmov %dl,0x5(%di)\t\t# Set P:DPL:type\n"
"\t\tadd $0x4,%ax\t\t\t# Next handler\n"
"init.3:\t\tlea 0x8(%di),%di\t\t# Next entry\n"
"\t\tloop init.2\t\t\t# Till set done\n"
"\t\tjmp init.1\t\t\t# Continue\n"
msgstr ""
"/*\n"
" * Create IDT.\n"
" */\n"
"\t\tmov $0x5e00,%di\t\t\t#Dirección de IDT\n"
"\t\tmov $idtctl,%si\t\t\t# Cadena de control\n"
"init.1:\t\tlodsb\t\t\t\t# Obtener entrada\n"
"\t\tcbw\t\t\t\t#  contar\n"
"\t\txchg %ax,%cx\t\t\t#  como palabra\n"
"\t\tjcxz init.4\t\t\t# Si esta hecho\n"
"\t\tlodsb\t\t\t\t# Obtener segmento\n"
"\t\txchg %ax,%dx\t\t\t#  P:DPL:tipo\n"
"\t\tlodsw\t\t\t\t# Toma el control\n"
"\t\txchg %ax,%bx\t\t\t#  conjunto\n"
"\t\tlodsw\t\t\t\t# Obtener compensación de controlador\n"
"\t\tmov $SEL_SCODE,%dh\t\t# Selector de segmento\n"
"init.2:\t\tshr %bx\t\t\t\t# Maneja este int?\n"
"\t\tjnc init.3\t\t\t# No\n"
"\t\tmov %ax,(%di)\t\t\t# Establecer compensación de controlador\n"
"\t\tmov %dh,0x2(%di)\t\t#  y selector\n"
"\t\tmov %dl,0x5(%di)\t\t# Conjunto P:DPL:tipo\n"
"\t\tadd $0x4,%ax\t\t\t# Siguiente controlador\n"
"init.3:\t\tlea 0x8(%di),%di\t\t# Entrada siguiente\n"
"\t\tloop init.2\t\t\t#Hasta que esté listo\n"
"\t\tjmp init.1\t\t\t# Seguir\n"

#. type: Block title
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:753
#, no-wrap
msgid "[.filename]#sys/boot/i386/btx/btx/btx.S# [[btx-idt]]"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:755
msgid ""
"Each entry in the `IDT` is 8 bytes long. Besides the segment/offset "
"information, they also describe the segment type, privilege level, and "
"whether the segment is present in memory or not. The construction is such "
"that interrupt vectors from `0` to `0xf` (exceptions) are handled by "
"function `intx00`; vector `0x10` (also an exception) is handled by `intx10`; "
"hardware interrupts, which are later configured to start at interrupt vector "
"`0x20` all the way to interrupt vector `0x2f`, are handled by function "
"`intx20`. Lastly, interrupt vector `0x30`, which is used for system calls, "
"is handled by `intx30`, and vectors `0x31` and `0x32` are handled by "
"`intx31`. It must be noted that only descriptors for interrupt vectors "
"`0x30`, `0x31` and `0x32` are given privilege level 3, the same privilege "
"level as the [.filename]#boot2# client, which means the client can execute a "
"software-generated interrupt to this vectors through the `int` instruction "
"without failing (this is the way [.filename]#boot2# use the services "
"provided by the BTX server). Also, note that _only_ software-generated "
"interrupts are protected from code executing in lesser privilege levels. "
"Hardware-generated interrupts and processor-generated exceptions are "
"_always_ handled adequately, regardless of the actual privileges involved."
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:757
msgid ""
"The next step is to initialize the TSS (Task-State Segment). The TSS is a "
"hardware feature that helps the operating system or executive software "
"implement multitasking functionality through process abstraction. The IA-32 "
"architecture demands the creation and use of _at least_ one TSS if "
"multitasking facilities are used or different privilege levels are defined. "
"Since the [.filename]#boot2# client is executed in privilege level 3, but "
"the BTX server runs in privilege level 0, a TSS must be defined:"
msgstr ""

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:766
#, no-wrap
msgid ""
"/*\n"
" * Initialize TSS.\n"
" */\n"
"init.4:\t\tmovb $_ESP0H,TSS_ESP0+1(%di)\t# Set ESP0\n"
"\t\tmovb $SEL_SDATA,TSS_SS0(%di)\t# Set SS0\n"
"\t\tmovb $_TSSIO,TSS_MAP(%di)\t# Set I/O bit map base\n"
msgstr ""

#. type: Block title
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:768
#, no-wrap
msgid "[.filename]#sys/boot/i386/btx/btx/btx.S# [[btx-tss]]"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:770
#, fuzzy
msgid ""
"Note that a value is given for the Privilege Level 0 stack pointer and stack "
"segment in the TSS. This is needed because, if an interrupt or exception is "
"received while executing [.filename]#boot2# in Privilege Level 3, a change "
"to Privilege Level 0 is automatically performed by the processor, so a new "
"working stack is needed. Finally, the I/O Map Base Address field of the TSS "
"is given a value, which is a 16-bit offset from the beginning of the TSS to "
"the I/O Permission Bitmap and the Interrupt Redirection Bitmap."
msgstr ""
"Tenga en cuenta que se proporciona un valor para el puntero de pila de nivel "
"de privilegio 0 y el segmento de pila en el <acronym>TSS</acronym>. Esto es "
"necesario porque, si se recibe una interrupción o excepción durante la "
"ejecución <filename>boot2</filename> en Privilege Level 3, el procesador "
"realiza automáticamente un cambio al Privilege Level 0, por lo que se "
"necesita una nueva pila de trabajo. Finalmente, el campo Dirección base del "
"mapa de E / S del <acronym>TSS</acronym> se le da un valor, que es un "
"desplazamiento de 16 bits desde el comienzo de la <acronym>TSS</acronym> al "
"mapa de bits de permisos de E / S y al mapa de bits de redirección de "
"interrupciones."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:772
msgid ""
"After the IDT and TSS are created, the processor is ready to switch to "
"protected mode. This is done in the next block:"
msgstr ""

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:790
#, fuzzy, no-wrap
msgid ""
"/*\n"
" * Bring up the system.\n"
" */\n"
"\t\tmov $0x2820,%bx\t\t\t# Set protected mode\n"
"\t\tcallw setpic\t\t\t#  IRQ offsets\n"
"\t\tlidt idtdesc\t\t\t# Set IDT\n"
"\t\tlgdt gdtdesc\t\t\t# Set GDT\n"
"\t\tmov %cr0,%eax\t\t\t# Switch to protected\n"
"\t\tinc %ax\t\t\t\t#  mode\n"
"\t\tmov %eax,%cr0\t\t\t#\n"
"\t\tljmp $SEL_SCODE,$init.8\t\t# To 32-bit code\n"
"\t\t.code32\n"
"init.8:\t\txorl %ecx,%ecx\t\t\t# Zero\n"
"\t\tmovb $SEL_SDATA,%cl\t\t# To 32-bit\n"
"\t\tmovw %cx,%ss\t\t\t#  stack\n"
msgstr ""
"/*\n"
" * Trae el sistema.\n"
" */\n"
"\t\tmov $0x2820,%bx\t\t\t# Establecer modo protegido\n"
"\t\tcallw setpic\t\t\t#  Compensaciones de IRQ\n"
"\t\tlidt idtdesc\t\t\t# Establecer IDT\n"
"\t\tlgdt gdtdesc\t\t\t# Establecer GDT\n"
"\t\tmov %cr0,%eax\t\t\t# Cambiar a protegido\n"
"\t\tinc %ax\t\t\t\t#  modo\n"
"\t\tmov %eax,%cr0\t\t\t#\n"
"\t\tljmp $SEL_SCODE,$init.8\t\t# A código de 32 bits\n"
"\t\t.code32\n"
"init.8:\t\txorl %ecx,%ecx\t\t\t# Cero\n"
"\t\tmovb $SEL_SDATA,%cl\t\t# A 32-bit\n"
"\t\tmovw %cx,%ss\t\t\t#  apilar\n"

#. type: Block title
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:792
#, no-wrap
msgid "[.filename]#sys/boot/i386/btx/btx/btx.S# [[btx-prot]]"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:794
#, fuzzy
msgid ""
"First, a call is made to `setpic` to program the 8259A PIC (Programmable "
"Interrupt Controller). This chip is connected to multiple hardware interrupt "
"sources. Upon receiving an interrupt from a device, it signals the processor "
"with the appropriate interrupt vector. This can be customized so that "
"specific interrupts are associated with specific interrupt vectors, as "
"explained before. Next, the IDTR (Interrupt Descriptor Table Register) and "
"GDTR (Global Descriptor Table Register) are loaded with the instructions "
"`lidt` and `lgdt`, respectively. These registers are loaded with the base "
"address and limit address for the IDT and GDT. The following three "
"instructions set the Protection Enable (PE) bit of the `%cr0` register. This "
"effectively switches the processor to 32-bit protected mode. Next, a long "
"jump is made to `init.8` using segment selector SEL_SCODE, which selects the "
"Supervisor Code Segment. The processor is effectively executing in CPL 0, "
"the most privileged level, after this jump. Finally, the Supervisor Data "
"Segment is selected for the stack by assigning the segment selector "
"SEL_SDATA to the `%ss` register. This data segment also has a privilege "
"level of `0`."
msgstr ""
"Primero, se hace una llamada a <literal>setpic</literal> para programar el "
"8259A <acronym>PIC</acronym> (Controlador de interrupción programable). Este "
"chip está conectado a múltiples fuentes de interrupción de hardware. Al "
"recibir una interrupción de un dispositivo, envía una señal al procesador "
"con el vector de interrupción apropiado. Esto se puede personalizar para que "
"las interrupciones específicas se asocien con vectores de interrupción "
"específicos, como se explicó antes. A continuación, el <acronym>IDTR</"
"acronym> (Registro de tabla de descriptores de interrupción) y<acronym>GDTR</"
"acronym> (Registro de tabla de descriptor global) se cargan con las "
"instrucciones <literal>lidt</literal> y <literal>lgdt</literal>, "
"respectivamente. Estos registros se cargan con la dirección base y la "
"dirección límite para el  <acronym>IDT</acronym> y <acronym>GDT</acronym>. "
"Las siguientes tres instrucciones establecen el bit de habilitación de "
"protección (PE) del<literal>%cr0</literal>Registrarse. Esto cambia "
"efectivamente el procesador al modo protegido de 32 bits. A continuación, se "
"realiza un salto de longitud para <literal>init.8</literal> utilizando el "
"selector de segmento SEL_SCODE, que selecciona el segmento de código de "
"supervisor. El procesador se está ejecutando efectivamente en CPL 0, el "
"nivel más privilegiado, después de este salto. Finalmente, el segmento de "
"datos del supervisor se selecciona para la pila asignando el selector de "
"segmento SEL_SDATA to the <literal>%ss</literal> registrar. Este segmento de "
"datos también tiene un nivel de privilegio de <literal>0</literal>."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:796
#, fuzzy
msgid ""
"Our last code block is responsible for loading the TR (Task Register) with "
"the segment selector for the TSS we created earlier, and setting the User "
"Mode environment before passing execution control to the [.filename]#boot2# "
"client."
msgstr ""
"Nuestro último bloque de código es responsable de cargar el <acronym>TR</"
"acronym> (Registro de tareas) con el selector de segmento para el "
"<acronym>TSS</acronym> que creamos anteriormente y configuramos el entorno "
"de modo de usuario antes de pasar el control de ejecución al<filename>boot2</"
"filename> cliente."

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:829
#, fuzzy, no-wrap
msgid ""
"/*\n"
" * Launch user task.\n"
" */\n"
"\t\tmovb $SEL_TSS,%cl\t\t# Set task\n"
"\t\tltr %cx\t\t\t\t#  register\n"
"\t\tmovl $0xa000,%edx\t\t# User base address\n"
"\t\tmovzwl %ss:BDA_MEM,%eax\t\t# Get free memory\n"
"\t\tshll $0xa,%eax\t\t\t# To bytes\n"
"\t\tsubl $ARGSPACE,%eax\t\t# Less arg space\n"
"\t\tsubl %edx,%eax\t\t\t# Less base\n"
"\t\tmovb $SEL_UDATA,%cl\t\t# User data selector\n"
"\t\tpushl %ecx\t\t\t# Set SS\n"
"\t\tpushl %eax\t\t\t# Set ESP\n"
"\t\tpush $0x202\t\t\t# Set flags (IF set)\n"
"\t\tpush $SEL_UCODE\t\t\t# Set CS\n"
"\t\tpushl btx_hdr+0xc\t\t# Set EIP\n"
"\t\tpushl %ecx\t\t\t# Set GS\n"
"\t\tpushl %ecx\t\t\t# Set FS\n"
"\t\tpushl %ecx\t\t\t# Set DS\n"
"\t\tpushl %ecx\t\t\t# Set ES\n"
"\t\tpushl %edx\t\t\t# Set EAX\n"
"\t\tmovb $0x7,%cl\t\t\t# Set remaining\n"
"init.9:\t\tpush $0x0\t\t\t#  general\n"
"\t\tloop init.9\t\t\t#  registers\n"
"\t\tpopa\t\t\t\t#  and initialize\n"
"\t\tpopl %es\t\t\t# Initialize\n"
"\t\tpopl %ds\t\t\t#  user\n"
"\t\tpopl %fs\t\t\t#  segment\n"
"\t\tpopl %gs\t\t\t#  registers\n"
"\t\tiret\t\t\t\t# To user mode\n"
msgstr ""
"/*\n"
" * Launch user task.\n"
" */\n"
"\t\tmovb $SEL_TSS,%cl\t\t# Establecer tarea\n"
"\t\tltr %cx\t\t\t\t#  registrar\n"
"\t\tmovl $0xa000,%edx\t\t# Dirección base de usuario\n"
"\t\tmovzwl %ss:BDA_MEM,%eax\t\t# Obtenga memoria libre\n"
"\t\tshll $0xa,%eax\t\t\t# A bytes\n"
"\t\tsubl $ARGSPACE,%eax\t\t# Menos espacio arg\n"
"\t\tsubl %edx,%eax\t\t\t# Menos base\n"
"\t\tmovb $SEL_UDATA,%cl\t\t# Selector de datos de usuario\n"
"\t\tpushl %ecx\t\t\t# Establecer SS\n"
"\t\tpushl %eax\t\t\t# Establecer ESP\n"
"\t\tpush $0x202\t\t\t# Establecer flags (IF set)\n"
"\t\tpush $SEL_UCODE\t\t\t# Establecer CS\n"
"\t\tpushl btx_hdr+0xc\t\t# Establecer EIP\n"
"\t\tpushl %ecx\t\t\t# Establecer GS\n"
"\t\tpushl %ecx\t\t\t# Establecer FS\n"
"\t\tpushl %ecx\t\t\t# Establecer DS\n"
"\t\tpushl %ecx\t\t\t# Establecer ES\n"
"\t\tpushl %edx\t\t\t# Establecer EAX\n"
"\t\tmovb $0x7,%cl\t\t\t# Establecer restante\n"
"init.9:\t\tpush $0x0\t\t\t#  general\n"
"\t\tloop init.9\t\t\t#  registros\n"
"\t\tpopa\t\t\t\t# e inicializar\n"
"\t\tpopl %es\t\t\t# Inicializar\n"
"\t\tpopl %ds\t\t\t#  usuario\n"
"\t\tpopl %fs\t\t\t#  segmento\n"
"\t\tpopl %gs\t\t\t#  registros\n"
"\t\tiret\t\t\t\t# Al modo de usuario\n"

#. type: Block title
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:831
#, no-wrap
msgid "[.filename]#sys/boot/i386/btx/btx/btx.S# [[btx-end]]"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:833
#, fuzzy
msgid ""
"Note that the client's environment include a stack segment selector and "
"stack pointer (registers `%ss` and `%esp`). Indeed, once the TR is loaded "
"with the appropriate stack segment selector (instruction `ltr`), the stack "
"pointer is calculated and pushed onto the stack along with the stack's "
"segment selector. Next, the value `0x202` is pushed onto the stack; it is "
"the value that the EFLAGS will get when control is passed to the client. "
"Also, the User Mode code segment selector and the client's entry point are "
"pushed. Recall that this entry point is patched in the BTX header at link "
"time. Finally, segment selectors (stored in register `%ecx`) for the segment "
"registers `%gs, %fs, %ds and %es` are pushed onto the stack, along with the "
"value at `%edx` (`0xa000`). Keep in mind the various values that have been "
"pushed onto the stack (they will be popped out shortly). Next, values for "
"the remaining general purpose registers are also pushed onto the stack (note "
"the `loop` that pushes the value `0` seven times). Now, values will be "
"started to be popped out of the stack. First, the `popa` instruction pops "
"out of the stack the latest seven values pushed. They are stored in the "
"general purpose registers in order `%edi, %esi, %ebp, %ebx, %edx, %ecx, "
"%eax`. Then, the various segment selectors pushed are popped into the "
"various segment registers. Five values still remain on the stack. They are "
"popped when the `iret` instruction is executed. This instruction first pops "
"the value that was pushed from the BTX header. This value is a pointer to [."
"filename]#boot2#'s entry point. It is placed in the register `%eip`, the "
"instruction pointer register. Next, the segment selector for the User Code "
"Segment is popped and copied to register `%cs`. Remember that this segment's "
"privilege level is 3, the least privileged level. This means that we must "
"provide values for the stack of this privilege level. This is why the "
"processor, besides further popping the value for the EFLAGS register, does "
"two more pops out of the stack. These values go to the stack pointer (`"
"%esp`) and the stack segment (`%ss`). Now, execution continues at "
"``boot0``'s entry point."
msgstr ""
"Tenga en cuenta que el entorno del cliente incluye un selector de segmento "
"de pila y un puntero de pila (registra <literal>%ss</literal> y "
"<literal>%esp</literal>). De hecho, una vez que el <acronym>TR</acronym> se "
"carga con el selector de segmento de pila apropiado (instrucción "
"<literal>ltr</literal>), el puntero de la pila se calcula y se inserta en la "
"pila junto con el selector de segmento de la pila. A continuación, el valor "
"<literal>0x202</literal> se empuja hacia la pila; es el valor que obtendrá "
"EFLAGS cuando el control se pase al cliente. Además, se presionan el "
"selector de segmento de código del modo de usuario y el punto de entrada del "
"cliente. Recuerde que este punto de entrada está parcheado en el "
"<acronym>BTX</acronym> encabezado en el momento del enlace. Finalmente, los "
"selectores de segmento (almacenados en el registro <literal>%ecx</literal>) "
"para los registros de segmento <literal>%gs, %fs, %ds and %es</literal> se "
"colocan en la pila, junto con el valor en <literal>%edx</literal> "
"(<literal>0xa000</literal>). Tenga en cuenta los diversos valores que se han "
"introducido en la pila (aparecerán en breve). A continuación, los valores de "
"los registros de propósito general restantes también se insertan en la pila ("
"tenga en cuenta el<literal>loop</literal> que empuja el valor <literal>0</"
"literal> siete veces). Ahora, los valores comenzarán a salir de la pila. "
"Primero el <literal>popa</literal>La instrucción emerge de la pila con los "
"últimos siete valores insertados. Se almacenan en los registros de propósito "
"general en orden <literal>%edi, %esi, %ebp, %ebx, %edx, %ecx, %eax</"
"literal>. Luego, los diversos selectores de segmento presionados se "
"introducen en los distintos registros de segmento. Aún quedan cinco valores "
"en la pila. Se reventan cuando el <literal>iret</literal> se ejecuta la "
"instrucción. Esta instrucción primero muestra el valor que fue empujado "
"desde el<acronym>BTX</acronym> encabezamiento. Este valor es un puntero a "
"<filename>boot2</filename>'s punto de entrada. Se coloca en el registro "
"<literal>%eip</literal>, el registro de puntero de instrucción. A "
"continuación, el selector de segmento para el segmento de código de usuario "
"se abre y se copia para registrar <literal>%cs</literal>. Recuerde que el "
"nivel de privilegio de este segmento es 3, el nivel menos privilegiado. Esto "
"significa que debemos proporcionar valores para la pila de este nivel de "
"privilegio. Esta es la razón por la que el procesador, además de extraer aún "
"más el valor del registro EFLAGS, hace dos salidas más de la pila. Estos "
"valores van al puntero de la pila(<literal>%esp</literal>) y el segmento de "
"pila (<literal>%ss</literal>).Ahora, la ejecución continúa en "
"<literal>boot0</literal>'s punto de entrada."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:835
msgid ""
"It is important to note how the User Code Segment is defined. This segment's "
"_base address_ is set to `0xa000`. This means that code memory addresses are "
"_relative_ to address 0xa000; if code being executed is fetched from address "
"`0x2000`, the _actual_ memory addressed is `0xa000+0x2000=0xc000`."
msgstr ""

#. type: Title ==
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:837
#, no-wrap
msgid "boot2 Stage"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:840
msgid ""
"`boot2` defines an important structure, `struct bootinfo`. This structure is "
"initialized by `boot2` and passed to the loader, and then further to the "
"kernel. Some nodes of this structures are set by `boot2`, the rest by the "
"loader. This structure, among other information, contains the kernel "
"filename, BIOS harddisk geometry, BIOS drive number for boot device, "
"physical memory available, `envp` pointer etc. The definition for it is:"
msgstr ""

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:865
#, no-wrap
msgid ""
"/usr/include/machine/bootinfo.h:\n"
"struct bootinfo {\n"
"\tu_int32_t\tbi_version;\n"
"\tu_int32_t\tbi_kernelname;\t\t/* represents a char * */\n"
"\tu_int32_t\tbi_nfs_diskless;\t/* struct nfs_diskless * */\n"
"\t\t\t\t/* End of fields that are always present. */\n"
"#define\tbi_endcommon\tbi_n_bios_used\n"
"\tu_int32_t\tbi_n_bios_used;\n"
"\tu_int32_t\tbi_bios_geom[N_BIOS_GEOM];\n"
"\tu_int32_t\tbi_size;\n"
"\tu_int8_t\tbi_memsizes_valid;\n"
"\tu_int8_t\tbi_bios_dev;\t\t/* bootdev BIOS unit number */\n"
"\tu_int8_t\tbi_pad[2];\n"
"\tu_int32_t\tbi_basemem;\n"
"\tu_int32_t\tbi_extmem;\n"
"\tu_int32_t\tbi_symtab;\t\t/* struct symtab * */\n"
"\tu_int32_t\tbi_esymtab;\t\t/* struct symtab * */\n"
"\t\t\t\t/* Items below only from advanced bootloader */\n"
"\tu_int32_t\tbi_kernend;\t\t/* end of kernel space */\n"
"\tu_int32_t\tbi_envp;\t\t/* environment */\n"
"\tu_int32_t\tbi_modulep;\t\t/* preloaded modules */\n"
"};\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:868
msgid ""
"`boot2` enters into an infinite loop waiting for user input, then calls "
"`load()`. If the user does not press anything, the loop breaks by a timeout, "
"so `load()` will load the default file ([.filename]#/boot/loader#). "
"Functions `ino_t lookup(char *filename)` and `int xfsread(ino_t inode, void "
"*buf, size_t nbyte)` are used to read the content of a file into memory. [."
"filename]#/boot/loader# is an ELF binary, but where the ELF header is "
"prepended with [.filename]#a.out#'s `struct exec` structure. `load()` scans "
"the loader's ELF header, loading the content of [.filename]#/boot/loader# "
"into memory, and passing the execution to the loader's entry:"
msgstr ""

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:875
#, no-wrap
msgid ""
"sys/boot/i386/boot2/boot2.c:\n"
"    __exec((caddr_t)addr, RB_BOOTINFO | (opts & RBX_MASK),\n"
"\t   MAKEBOOTDEV(dev_maj[dsk.type], 0, dsk.slice, dsk.unit, dsk.part),\n"
"\t   0, 0, 0, VTOP(&bootinfo));\n"
msgstr ""

#. type: Title ==
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:878
#, no-wrap
msgid "loader Stage"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:881
msgid ""
"loader is a BTX client as well. I will not describe it here in detail, there "
"is a comprehensive man page written by Mike Smith, man:loader[8]. The "
"underlying mechanisms and BTX were discussed above."
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:883
msgid ""
"The main task for the loader is to boot the kernel. When the kernel is "
"loaded into memory, it is being called by the loader:"
msgstr ""
"La tarea principal del cargador es arrancar el núcleo. Cuando el núcleo se "
"carga en la memoria, el cargador lo llama:"

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:889
#, no-wrap
msgid ""
"sys/boot/common/boot.c:\n"
"    /* Call the exec handler from the loader matching the kernel */\n"
"    module_formats[km->m_loader]->l_exec(km);\n"
msgstr ""

#. type: Title ==
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:892
#, no-wrap
msgid "Kernel Initialization"
msgstr "Inicialización del kernel"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:895
msgid ""
"Let us take a look at the command that links the kernel. This will help "
"identify the exact location where the loader passes execution to the kernel. "
"This location is the kernel's actual entry point."
msgstr ""
"Echemos un vistazo al comando que enlaza el kernel. Esto ayudará a "
"identificar la ubicación exacta donde el cargador pasa la ejecución al "
"kernel. Esta ubicación es el punto de entrada real del kernel."

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:902
#, no-wrap
msgid ""
"sys/conf/Makefile.i386:\n"
"ld -elf -Bdynamic -T /usr/src/sys/conf/ldscript.i386  -export-dynamic \\\n"
"-dynamic-linker /red/herring -o kernel -X locore.o \\\n"
"<lots of kernel .o files>\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:905
msgid ""
"A few interesting things can be seen here. First, the kernel is an ELF "
"dynamically linked binary, but the dynamic linker for kernel is [.filename]#/"
"red/herring#, which is definitely a bogus file. Second, taking a look at the "
"file [.filename]#sys/conf/ldscript.i386# gives an idea about what ld options "
"are used when compiling a kernel. Reading through the first few lines, the "
"string"
msgstr ""

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:910
#, no-wrap
msgid ""
"sys/conf/ldscript.i386:\n"
"ENTRY(btext)\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:913
#, fuzzy
msgid ""
"says that a kernel's entry point is the symbol `btext`. This symbol is "
"defined in [.filename]#locore.s#:"
msgstr ""
"dice que el punto de entrada de un kernel es el símbolo 'btext'. Este "
"símbolo se define en <filename>locore.s</filename>:"

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:924
#, no-wrap
msgid ""
"sys/i386/i386/locore.s:\n"
"\t.text\n"
"/**********************************************************************\n"
" *\n"
" * This is where the bootblocks start us, set the ball rolling...\n"
" *\n"
" */\n"
"NON_GPROF_ENTRY(btext)\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:927
msgid ""
"First, the register EFLAGS is set to a predefined value of 0x00000002. Then "
"all the segment registers are initialized:"
msgstr ""
"Primero, el registro EFLAGS se establece en un valor predefinido de "
"0x00000002. Luego se inicializan todos los registros de segmento:"

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:934
#, no-wrap
msgid ""
"sys/i386/i386/locore.s:\n"
"/* Don't trust what the BIOS gives for eflags. */\n"
"\tpushl\t$PSL_KERNEL\n"
"\tpopfl\n"
msgstr ""

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:942
#, no-wrap
msgid ""
"/*\n"
" * Don't trust what the BIOS gives for %fs and %gs.  Trust the bootstrap\n"
" * to set %cs, %ds, %es and %ss.\n"
" */\n"
"\tmov\t%ds, %ax\n"
"\tmov\t%ax, %fs\n"
"\tmov\t%ax, %gs\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:945
msgid ""
"btext calls the routines `recover_bootinfo()`, `identify_cpu()`, "
"`create_pagetables()`, which are also defined in [.filename]#locore.s#. Here "
"is a description of what they do:"
msgstr ""

#. type: Table
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:958
#, no-wrap
msgid ""
"|`recover_bootinfo`\n"
"|This routine parses the parameters to the kernel passed from the bootstrap. The kernel may have been booted in 3 ways: by the loader, described above, by the old disk boot blocks, or by the old diskless boot procedure. This function determines the booting method, and stores the `struct bootinfo` structure into the kernel memory.\n"
"\n"
"|`identify_cpu`\n"
"|This functions tries to find out what CPU it is running on, storing the value found in a variable `_cpu`.\n"
"\n"
"|`create_pagetables`\n"
"|This function allocates and fills out a Page Table Directory at the top of the kernel memory area.\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:961
msgid "The next steps are enabling VME, if the CPU supports it:"
msgstr "Los siguientes pasos son habilitar VME, si la CPU lo admite:"

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:969
#, no-wrap
msgid ""
"\ttestl\t$CPUID_VME, R(_cpu_feature)\n"
"\tjz\t1f\n"
"\tmovl\t%cr4, %eax\n"
"\torl\t$CR4_VME, %eax\n"
"\tmovl\t%eax, %cr4\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:972
msgid "Then, enabling paging:"
msgstr "Luego, habilitando la paginación:"

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:981
#, fuzzy, no-wrap
msgid ""
"/* Now enable paging */\n"
"\tmovl\tR(_IdlePTD), %eax\n"
"\tmovl\t%eax,%cr3\t\t\t/* load ptd addr into mmu */\n"
"\tmovl\t%cr0,%eax\t\t\t/* get control word */\n"
"\torl\t$CR0_PE|CR0_PG,%eax\t\t/* enable paging */\n"
"\tmovl\t%eax,%cr0\t\t\t/* and let's page NOW! */\n"
msgstr ""
"/* Now enable paging */\n"
"\tmovl\tR(_IdlePTD), %eax\n"
"\tmovl\t%eax,%cr3\t\t\t/* cargar ptd addr en mmu */\n"
"\tmovl\t%cr0,%eax\t\t\t/* obtener palabra de control */\n"
"\torl\t$CR0_PE|CR0_PG,%eax\t\t/*habilitar paginación */\n"
"\tmovl\t%eax,%cr0\t\t\t/*y busquemos AHORA! */\n"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:984
msgid ""
"The next three lines of code are because the paging was set, so the jump is "
"needed to continue the execution in virtualized address space:"
msgstr ""
"Las siguientes tres líneas de código se deben a que se configuró la "
"paginación, por lo que se necesita el salto para continuar la ejecución en "
"el espacio de direcciones virtualizado:"

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:989
#, no-wrap
msgid ""
"\tpushl\t$begin\t\t\t\t/* jump to high virtualized address */\n"
"\tret\n"
msgstr ""

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:992
#, no-wrap
msgid ""
"/* now running relocated at KERNBASE where the system is linked to run */\n"
"begin:\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:995
msgid ""
"The function `init386()` is called with a pointer to the first free physical "
"page, after that `mi_startup()`. `init386` is an architecture dependent "
"initialization function, and `mi_startup()` is an architecture independent "
"one (the 'mi_' prefix stands for Machine Independent). The kernel never "
"returns from `mi_startup()`, and by calling it, the kernel finishes booting:"
msgstr ""

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:1004
#, fuzzy, no-wrap
msgid ""
"sys/i386/i386/locore.s:\n"
"\tmovl\tphysfree, %esi\n"
"\tpushl\t%esi\t\t\t\t/* value of first for init386(first) */\n"
"\tcall\t_init386\t\t\t/* wire 386 chip for unix operation */\n"
"\tcall\t_mi_startup\t\t\t/* autoconfiguration, mountroot etc */\n"
"\thlt\t\t/* never returns to here */\n"
msgstr ""
"<filename>sys/i386/i386/locore.s:</filename>\n"
"\tmovl\tphysfree, %esi\n"
"\tpushl\t%esi\t\t\t\t/* valor de primero para init386 (primero) */\n"
"\tcall\t_init386\t\t\t/*chip de alambre 386 para operación Unix */\n"
"\tcall\t_mi_startup\t\t\t/* autoconfiguración, mountroot, etc. */\n"
"\thlt\t\t/* nunca vuelve a aqui*/\n"

#. type: Title ===
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:1006
#, no-wrap
msgid "`init386()`"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:1009
#, fuzzy
msgid ""
"`init386()` is defined in [.filename]#sys/i386/i386/machdep.c# and performs "
"low-level initialization specific to the i386 chip. The switch to protected "
"mode was performed by the loader. The loader has created the very first "
"task, in which the kernel continues to operate. Before looking at the code, "
"consider the tasks the processor must complete to initialize protected mode "
"execution:"
msgstr ""
"<function>init386()</function> se define en <filename>sys/i386/i386/machdep."
"c</filename> y realiza una inicialización de bajo nivel específica para el "
"chip i386. El cambio al modo protegido fue realizado por el cargador. El "
"cargador ha creado la primera tarea, en la que el kernel sigue funcionando. "
"Antes de mirar el código, considere las tareas que el procesador debe "
"completar para inicializar la ejecución del modo protegido:"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:1011
msgid ""
"Initialize the kernel tunable parameters, passed from the bootstrapping "
"program."
msgstr ""
"Inicialice los parámetros ajustables del kernel, pasados desde el programa "
"de arranque."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:1012
msgid "Prepare the GDT."
msgstr "Prepare el GDT."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:1013
msgid "Prepare the IDT."
msgstr "Prepare el IDT."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:1014
msgid "Initialize the system console."
msgstr "Inicialice la consola del sistema."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:1015
msgid "Initialize the DDB, if it is compiled into kernel."
msgstr "Inicialice el DDB, si está compilado en el kernel."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:1016
msgid "Initialize the TSS."
msgstr "Inicialice el TSS."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:1017
msgid "Prepare the LDT."
msgstr "Prepare el LDT."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:1018
msgid "Set up proc0's pcb."
msgstr "Configure la pcb de proc0."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:1020
msgid ""
"`init386()` initializes the tunable parameters passed from bootstrap by "
"setting the environment pointer (envp) and calling `init_param1()`. The envp "
"pointer has been passed from loader in the `bootinfo` structure:"
msgstr ""

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:1025
#, no-wrap
msgid ""
"sys/i386/i386/machdep.c:\n"
"\t\tkern_envp = (caddr_t)bootinfo.bi_envp + KERNBASE;\n"
msgstr ""

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:1028
#, no-wrap
msgid ""
"\t/* Init basic tunables, hz etc */\n"
"\tinit_param1();\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:1031
msgid ""
"`init_param1()` is defined in [.filename]#sys/kern/subr_param.c#. That file "
"has a number of sysctls, and two functions, `init_param1()` and "
"`init_param2()`, that are called from `init386()`:"
msgstr ""

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:1037
#, no-wrap
msgid ""
"sys/kern/subr_param.c:\n"
"\thz = HZ;\n"
"\tTUNABLE_INT_FETCH(\"kern.hz\", &hz);\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:1040
msgid ""
"TUNABLE_<typename>_FETCH is used to fetch the value from the environment:"
msgstr ""

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:1045
#, no-wrap
msgid ""
"/usr/src/sys/sys/kernel.h:\n"
"#define\tTUNABLE_INT_FETCH(path, var)\tgetenv_int((path), (var))\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:1048
msgid ""
"Sysctl `kern.hz` is the system clock tick. Additionally, these sysctls are "
"set by `init_param1()`: `kern.maxswzone, kern.maxbcache, kern.maxtsiz, kern."
"dfldsiz, kern.maxdsiz, kern.dflssiz, kern.maxssiz, kern.sgrowsiz`."
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:1050
#, fuzzy
msgid ""
"Then `init386()` prepares the Global Descriptors Table (GDT). Every task on "
"an x86 is running in its own virtual address space, and this space is "
"addressed by a segment:offset pair. Say, for instance, the current "
"instruction to be executed by the processor lies at CS:EIP, then the linear "
"virtual address for that instruction would be \"the virtual address of code "
"segment CS\" + EIP. For convenience, segments begin at virtual address 0 and "
"end at a 4Gb boundary. Therefore, the instruction's linear virtual address "
"for this example would just be the value of EIP. Segment registers such as "
"CS, DS etc are the selectors, i.e., indexes, into GDT (to be more precise, "
"an index is not a selector itself, but the INDEX field of a selector). "
"FreeBSD's GDT holds descriptors for 15 selectors per CPU:"
msgstr ""
"Luego <function>init386()</function> prepara la Tabla de descriptores "
"globales (GDT). Cada tarea en un x86 se ejecuta en su propio espacio de "
"direcciones virtuales, y este espacio está dirigido por un segmento: par de "
"compensación. Digamos, por ejemplo, que la instrucción actual que ejecutará "
"el procesador se encuentra en CS: EIP, entonces la dirección virtual lineal "
"para esa instrucción sería <quote> la dirección virtual del segmento de "
"código CS</quote> + EIP. Para mayor comodidad, los segmentos comienzan en la "
"dirección virtual 0 y terminan en un límite de 4Gb. Por lo tanto, la "
"dirección virtual lineal de la instrucción para este ejemplo sería "
"simplemente el valor de EIP. Los registros de segmento como CS, DS, etc.son "
"los selectores, es decir, los índices, en GDT (para ser más precisos, un "
"índice no es un selector en sí mismo, sino el campo INDEX de un selector). "
"El GDT de FreeBSD contiene descriptores para 15 selectores por CPU:"

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:1055
#, no-wrap
msgid ""
"sys/i386/i386/machdep.c:\n"
"union descriptor gdt[NGDT * MAXCPU];\t/* global descriptor table */\n"
msgstr ""

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:1075
#, no-wrap
msgid ""
"sys/i386/include/segments.h:\n"
"/*\n"
" * Entries in the Global Descriptor Table (GDT)\n"
" */\n"
"#define\tGNULL_SEL\t0\t/* Null Descriptor */\n"
"#define\tGCODE_SEL\t1\t/* Kernel Code Descriptor */\n"
"#define\tGDATA_SEL\t2\t/* Kernel Data Descriptor */\n"
"#define\tGPRIV_SEL\t3\t/* SMP Per-Processor Private Data */\n"
"#define\tGPROC0_SEL\t4\t/* Task state process slot zero and up */\n"
"#define\tGLDT_SEL\t5\t/* LDT - eventually one per process */\n"
"#define\tGUSERLDT_SEL\t6\t/* User LDT */\n"
"#define\tGTGATE_SEL\t7\t/* Process task switch gate */\n"
"#define\tGBIOSLOWMEM_SEL\t8\t/* BIOS low memory access (must be entry 8) */\n"
"#define\tGPANIC_SEL\t9\t/* Task state to consider panic from */\n"
"#define GBIOSCODE32_SEL\t10\t/* BIOS interface (32bit Code) */\n"
"#define GBIOSCODE16_SEL\t11\t/* BIOS interface (16bit Code) */\n"
"#define GBIOSDATA_SEL\t12\t/* BIOS interface (Data) */\n"
"#define GBIOSUTIL_SEL\t13\t/* BIOS interface (Utility) */\n"
"#define GBIOSARGS_SEL\t14\t/* BIOS interface (Arguments) */\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:1078
msgid ""
"Note that those #defines are not selectors themselves, but just a field "
"INDEX of a selector, so they are exactly the indices of the GDT. for "
"example, an actual selector for the kernel code (GCODE_SEL) has the value "
"0x08."
msgstr ""
"Tenga en cuenta que esos #defines no son selectores en sí mismos, sino solo "
"un INDICE de campo de un selector, por lo que son exactamente los índices "
"del GDT. por ejemplo, un selector real para el código del kernel (GCODE_SEL) "
"tiene el valor 0x08."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:1080
#, fuzzy
msgid ""
"The next step is to initialize the Interrupt Descriptor Table (IDT). This "
"table is referenced by the processor when a software or hardware interrupt "
"occurs. For example, to make a system call, user application issues the `INT "
"0x80` instruction. This is a software interrupt, so the processor's hardware "
"looks up a record with index 0x80 in the IDT. This record points to the "
"routine that handles this interrupt, in this particular case, this will be "
"the kernel's syscall gate. The IDT may have a maximum of 256 (0x100) "
"records. The kernel allocates NIDT records for the IDT, where NIDT is the "
"maximum (256):"
msgstr ""
"El siguiente paso es inicializar la tabla de descriptores de interrupciones "
"(IDT). El procesador hace referencia a esta tabla cuando se produce una "
"interrupción de software o hardware. Por ejemplo, para realizar una llamada "
"al sistema, la aplicación de usuario emite <literal>INT 0x80</literal> "
"instrucción. Esta es una interrupción de software, por lo que el hardware "
"del procesador busca un registro con índice 0x80 en el IDT. Este registro "
"apunta a la rutina que maneja esta interrupción, en este caso particular, "
"esta será la puerta de llamada al sistema del kernel. El IDT puede tener un "
"máximo de 256 (0x100) registros. El kernel asigna registros NIDT para el "
"IDT, donde NIDT es el máximo (256):"

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:1086
#, no-wrap
msgid ""
"sys/i386/i386/machdep.c:\n"
"static struct gate_descriptor idt0[NIDT];\n"
"struct gate_descriptor *idt = &idt0[0];\t/* interrupt descriptor table */\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:1089
msgid ""
"For each interrupt, an appropriate handler is set. The syscall gate for `INT "
"0x80` is set as well:"
msgstr ""

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:1095
#, no-wrap
msgid ""
"sys/i386/i386/machdep.c:\n"
"\tsetidt(0x80, &IDTVEC(int0x80_syscall),\n"
"\t\t\tSDT_SYS386TGT, SEL_UPL, GSEL(GCODE_SEL, SEL_KPL));\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:1098
msgid ""
"So when a userland application issues the `INT 0x80` instruction, control "
"will transfer to the function `_Xint0x80_syscall`, which is in the kernel "
"code segment and will be executed with supervisor privileges."
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:1100
msgid "Console and DDB are then initialized:"
msgstr "A continuación, se inicializan la consola y DDB:"

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:1111
#, no-wrap
msgid ""
"sys/i386/i386/machdep.c:\n"
"\tcninit();\n"
"/* skipped */\n"
"#ifdef DDB\n"
"\tkdb_init();\n"
"\tif (boothowto & RB_KDB)\n"
"\t\tDebugger(\"Boot flags requested debugger\");\n"
"#endif\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:1114
msgid ""
"The Task State Segment is another x86 protected mode structure, the TSS is "
"used by the hardware to store task information when a task switch occurs."
msgstr ""
"El segmento de estado de la tarea es otra estructura de modo protegido x86, "
"el hardware utiliza el TSS para almacenar información de la tarea cuando se "
"produce un cambio de tarea."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:1116
msgid ""
"The Local Descriptors Table is used to reference userland code and data. "
"Several selectors are defined to point to the LDT, they are the system call "
"gates and the user code and data selectors:"
msgstr ""
"La tabla de descriptores locales se utiliza para hacer referencia al código "
"y los datos del área de usuario. Se definen varios selectores para apuntar "
"al LDT, son las puertas de llamada del sistema y los selectores de código de "
"usuario y datos:"

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:1130
#, no-wrap
msgid ""
"/usr/include/machine/segments.h:\n"
"#define\tLSYS5CALLS_SEL\t0\t/* forced by intel BCS */\n"
"#define\tLSYS5SIGR_SEL\t1\n"
"#define\tL43BSDCALLS_SEL\t2\t/* notyet */\n"
"#define\tLUCODE_SEL\t3\n"
"#define\tLSOL26CALLS_SEL\t4\t/* Solaris >= 2.6 system call gate */\n"
"#define\tLUDATA_SEL\t5\n"
"/* separate stack, es,fs,gs sels ? */\n"
"/* #define\tLPOSIXCALLS_SEL\t5*/\t/* notyet */\n"
"#define LBSDICALLS_SEL\t16\t/* BSDI system call gate */\n"
"#define NLDT\t\t(LBSDICALLS_SEL + 1)\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:1133
#, fuzzy
msgid ""
"Next, proc0's Process Control Block (`struct pcb`) structure is initialized. "
"proc0 is a `struct proc` structure that describes a kernel process. It is "
"always present while the kernel is running, therefore it is declared as "
"global:"
msgstr ""
"A continuación, el bloque de control de procesos de proc0(<literal>struct "
"pcb</literal>) se inicializa la estructura. proc0 es un <literal>struct "
"proc</literal> estructura que describe un proceso del kernel. Siempre está "
"presente mientras se ejecuta el kernel, por lo tanto, se declara como global:"

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:1138
#, no-wrap
msgid ""
"sys/kern/kern_init.c:\n"
"    struct\tproc proc0;\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:1141
#, fuzzy
msgid ""
"The structure `struct pcb` is a part of a proc structure. It is defined in [."
"filename]#/usr/include/machine/pcb.h# and has a process's information "
"specific to the i386 architecture, such as registers values."
msgstr ""
"La estructura <literal>struct pcb</literal>es parte de una estructura proc. "
"Se define en <filename>/usr/include/machine/pcb.h</filename> y tiene "
"información de un proceso específica para la arquitectura i386, como "
"registros de valores."

#. type: Title ===
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:1142
#, no-wrap
msgid "`mi_startup()`"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:1145
msgid ""
"This function performs a bubble sort of all the system initialization "
"objects and then calls the entry of each object one by one:"
msgstr ""
"Esta función realiza una especie de burbuja de todos los objetos de "
"inicialización del sistema y luego llama a la entrada de cada objeto uno por "
"uno:"

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:1150
#, no-wrap
msgid ""
"sys/kern/init_main.c:\n"
"\tfor (sipp = sysinit; *sipp; sipp++) {\n"
msgstr ""

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:1152
#, no-wrap
msgid "\t\t/* ... skipped ... */\n"
msgstr ""

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:1157
#, no-wrap
msgid ""
"\t\t/* Call function */\n"
"\t\t(*((*sipp)->func))((*sipp)->udata);\n"
"\t\t/* ... skipped ... */\n"
"\t}\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:1160
msgid ""
"Although the sysinit framework is described in the link:/books/developers-"
"handbook[Developers' Handbook], I will discuss the internals of it."
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:1162
msgid ""
"Every system initialization object (sysinit object) is created by calling a "
"SYSINIT() macro. Let us take as example an `announce` sysinit object. This "
"object prints the copyright message:"
msgstr ""

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:1172
#, no-wrap
msgid ""
"sys/kern/init_main.c:\n"
"static void\n"
"print_caddr_t(void *data __unused)\n"
"{\n"
"\tprintf(\"%s\", (char *)data);\n"
"}\n"
"SYSINIT(announce, SI_SUB_COPYRIGHT, SI_ORDER_FIRST, print_caddr_t, copyright)\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:1175
msgid ""
"The subsystem ID for this object is SI_SUB_COPYRIGHT (0x0800001), which "
"comes right after the SI_SUB_CONSOLE (0x0800000). So, the copyright message "
"will be printed out first, just after the console initialization."
msgstr ""
"El ID de subsistema para este objeto es SI_SUB_COPYRIGHT (0x0800001), que "
"viene justo después de SI_SUB_CONSOLE (0x0800000). Por lo tanto, el mensaje "
"de copyright se imprimirá primero, justo después de la inicialización de la "
"consola."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:1177
msgid ""
"Let us take a look at what exactly the macro `SYSINIT()` does. It expands to "
"a `C_SYSINIT()` macro. The `C_SYSINIT()` macro then expands to a static "
"`struct sysinit` structure declaration with another `DATA_SET` macro call:"
msgstr ""

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:1185
#, no-wrap
msgid ""
"/usr/include/sys/kernel.h:\n"
"      #define C_SYSINIT(uniquifier, subsystem, order, func, ident) \\\n"
"      static struct sysinit uniquifier ## _sys_init = { \\ subsystem, \\\n"
"      order, \\ func, \\ ident \\ }; \\ DATA_SET(sysinit_set,uniquifier ##\n"
"      _sys_init);\n"
msgstr ""

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:1189
#, no-wrap
msgid ""
"#define\tSYSINIT(uniquifier, subsystem, order, func, ident)\t\\\n"
"\tC_SYSINIT(uniquifier, subsystem, order,\t\t\t\\\n"
"\t(sysinit_cfunc_t)(sysinit_nfunc_t)func, (void *)ident)\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:1192
msgid ""
"The `DATA_SET()` macro expands to a `MAKE_SET()`, and that macro is the "
"point where all the sysinit magic is hidden:"
msgstr ""

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:1204
#, no-wrap
msgid ""
"/usr/include/linker_set.h:\n"
"#define MAKE_SET(set, sym)\t\t\t\t\t\t\\\n"
"\tstatic void const * const __set_##set##_sym_##sym = sym;\t\\\n"
"\t__asm(\".section .set.\" #set \",\\\"aw\\\"\");\t\t\t\t\\\n"
"\t__asm(\".long \" #sym);\t\t\t\t\t\t\\\n"
"\t__asm(\".previous\")\n"
"#endif\n"
"#define TEXT_SET(set, sym) MAKE_SET(set, sym)\n"
"#define DATA_SET(set, sym) MAKE_SET(set, sym)\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:1207
msgid "In our case, the following declaration will occur:"
msgstr "En nuestro caso se producirá la siguiente declaración:"

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:1216
#, no-wrap
msgid ""
"static struct sysinit announce_sys_init = {\n"
"\tSI_SUB_COPYRIGHT,\n"
"\tSI_ORDER_FIRST,\n"
"\t(sysinit_cfunc_t)(sysinit_nfunc_t)  print_caddr_t,\n"
"\t(void *) copyright\n"
"};\n"
msgstr ""

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:1222
#, no-wrap
msgid ""
"static void const *const __set_sysinit_set_sym_announce_sys_init =\n"
"    announce_sys_init;\n"
"__asm(\".section .set.sysinit_set\" \",\\\"aw\\\"\");\n"
"__asm(\".long \" \"announce_sys_init\");\n"
"__asm(\".previous\");\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:1225
#, fuzzy
msgid ""
"The first `__asm` instruction will create an ELF section within the kernel's "
"executable. This will happen at kernel link time. The section will have the "
"name `.set.sysinit_set`. The content of this section is one 32-bit value, "
"the address of announce_sys_init structure, and that is what the second "
"`__asm` is. The third `__asm` instruction marks the end of a section. If a "
"directive with the same section name occurred before, the content, i.e., the "
"32-bit value, will be appended to the existing section, so forming an array "
"of 32-bit pointers."
msgstr ""
"El primero <literal>__asm</literal>La instrucción creará una sección ELF "
"dentro del ejecutable del kernel. Esto sucederá en el momento del enlace del "
"kernel. La sección tendrá el nombre<literal>.set.sysinit_set</literal>. El "
"contenido de esta sección es un valor de 32 bits, la dirección de la "
"estructura publish_sys_init, y eso es lo que el segundo <literal>__asm</"
"literal> es. El tercero <literal>__asm</literal> instrucción marca el final "
"de una sección. Si antes se produjo una directiva con el mismo nombre de "
"sección, el contenido, es decir, el valor de 32 bits, se agregará a la "
"sección existente, formando una matriz de punteros de 32 bits."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:1227
msgid ""
"Running objdump on a kernel binary, you may notice the presence of such "
"small sections:"
msgstr ""

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:1243
#, no-wrap
msgid ""
"% objdump -h /kernel\n"
"  7 .set.cons_set 00000014  c03164c0  c03164c0  002154c0  2**2\n"
"                  CONTENTS, ALLOC, LOAD, DATA\n"
"  8 .set.kbddriver_set 00000010  c03164d4  c03164d4  002154d4  2**2\n"
"                  CONTENTS, ALLOC, LOAD, DATA\n"
"  9 .set.scrndr_set 00000024  c03164e4  c03164e4  002154e4  2**2\n"
"                  CONTENTS, ALLOC, LOAD, DATA\n"
" 10 .set.scterm_set 0000000c  c0316508  c0316508  00215508  2**2\n"
"                  CONTENTS, ALLOC, LOAD, DATA\n"
" 11 .set.sysctl_set 0000097c  c0316514  c0316514  00215514  2**2\n"
"                  CONTENTS, ALLOC, LOAD, DATA\n"
" 12 .set.sysinit_set 00000664  c0316e90  c0316e90  00215e90  2**2\n"
"                  CONTENTS, ALLOC, LOAD, DATA\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:1246
#, fuzzy
msgid ""
"This screen dump shows that the size of .set.sysinit_set section is 0x664 "
"bytes, so `0x664/sizeof(void *)` sysinit objects are compiled into the "
"kernel. The other sections such as `.set.sysctl_set` represent other linker "
"sets."
msgstr ""
"Este volcado de pantalla muestra que el tamaño de la sección ."
"set.sysinit_set es 0x664 bytes, por lo que <literal>0x664/sizeof(void *)</"
"literal> Los objetos sysinit se compilan en el kernel. Las otras secciones "
"como <literal>.set.sysctl_set</literal> representan otros conjuntos de "
"enlazadores."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:1248
msgid ""
"By defining a variable of type `struct linker_set` the content of `.set."
"sysinit_set` section will be \"collected\" into that variable:"
msgstr ""

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:1253
#, no-wrap
msgid ""
"sys/kern/init_main.c:\n"
"      extern struct linker_set sysinit_set; /* XXX */\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:1256
msgid "The `struct linker_set` is defined as follows:"
msgstr ""

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:1264
#, no-wrap
msgid ""
"/usr/include/linker_set.h:\n"
"  struct linker_set {\n"
"\tint\tls_length;\n"
"\tvoid\t*ls_items[1];\t\t/* really ls_length of them, trailing NULL */\n"
"};\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:1267
msgid ""
"The first node will be equal to the number of a sysinit objects, and the "
"second node will be a NULL-terminated array of pointers to them."
msgstr ""
"El primer nodo será igual al número de objetos sysinit, y el segundo nodo "
"será una matriz de punteros terminados en NULO."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:1269
#, fuzzy
msgid ""
"Returning to the `mi_startup()` discussion, it is must be clear now, how the "
"sysinit objects are being organized. The `mi_startup()` function sorts them "
"and calls each. The very last object is the system scheduler:"
msgstr ""
"Volviendo al <function>mi_startup()</function> discusión, debe quedar claro "
"ahora, cómo se están organizando los objetos sysinit. "
"los<function>mi_startup()</function> la función los ordena y llama a cada "
"uno. El último objeto es el programador del sistema:"

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:1281
#, fuzzy, no-wrap
msgid ""
"/usr/include/sys/kernel.h:\n"
"enum sysinit_sub_id {\n"
"\tSI_SUB_DUMMY\t\t= 0x0000000,\t/* not executed; for linker*/\n"
"\tSI_SUB_DONE\t\t= 0x0000001,\t/* processed*/\n"
"\tSI_SUB_CONSOLE\t\t= 0x0800000,\t/* console*/\n"
"\tSI_SUB_COPYRIGHT\t= 0x0800001,\t/* first use of console*/\n"
"...\n"
"\tSI_SUB_RUN_SCHEDULER\t= 0xfffffff\t/* scheduler: no return*/\n"
"};\n"
msgstr ""
"<filename>/usr/include/sys/kernel.h:</filename>\n"
"enum sysinit_sub_id {\n"
"\tSI_SUB_DUMMY\t\t= 0x0000000,\t/* sin ejecutar; para enlazador*/\n"
"\tSI_SUB_DONE\t\t= 0x0000001,\t/* procesada*/\n"
"\tSI_SUB_CONSOLE\t\t= 0x0800000,\t/* consola*/\n"
"\tSI_SUB_COPYRIGHT\t= 0x0800001,\t/* primer uso de la consola*/\n"
"...\n"
"\tSI_SUB_RUN_SCHEDULER\t= 0xfffffff\t/*Planificador: sin retorno*/\n"
"};\n"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:1284
#, fuzzy
msgid ""
"The system scheduler sysinit object is defined in the file [.filename]#sys/"
"vm/vm_glue.c#, and the entry point for that object is `scheduler()`. That "
"function is actually an infinite loop, and it represents a process with PID "
"0, the swapper process. The proc0 structure, mentioned before, is used to "
"describe it."
msgstr ""
"El objeto sysinit del programador del sistema se define en el archivo "
"<filename>sys/vm/vm_glue.c</filename>, y el punto de entrada para ese objeto "
"es <function>scheduler()</function>. Esa función es en realidad un bucle "
"infinito y representa un proceso con PID 0, el proceso de intercambio. La "
"estructura proc0, mencionada anteriormente, se usa para describirlo."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:1286
msgid ""
"The first user process, called _init_, is created by the sysinit object "
"`init`:"
msgstr ""

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:1295
#, no-wrap
msgid ""
"sys/kern/init_main.c:\n"
"static void\n"
"create_init(const void *udata __unused)\n"
"{\n"
"\tint error;\n"
"\tint s;\n"
msgstr ""

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:1306
#, no-wrap
msgid ""
"\ts = splhigh();\n"
"\terror = fork1(proc0, RFFDG | RFPROC, initproc);\n"
"\tif (error)\n"
"\t\tpanic(\"cannot fork init: %d\\n\", error);\n"
"\tinitproc-p_flag |= P_INMEM | P_SYSTEM;\n"
"\tcpu_set_fork_handler(initproc, start_init, NULL);\n"
"\tremrunqueue(initproc);\n"
"\tsplx(s);\n"
"}\n"
"SYSINIT(init,SI_SUB_CREATE_INIT, SI_ORDER_FIRST, create_init, NULL)\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:1309
msgid ""
"The `create_init()` allocates a new process by calling `fork1()`, but does "
"not mark it runnable. When this new process is scheduled for execution by "
"the scheduler, the `start_init()` will be called. That function is defined "
"in [.filename]#init_main.c#. It tries to load and exec the [.filename]#init# "
"binary, probing [.filename]#/sbin/init# first, then [.filename]#/sbin/"
"oinit#, [.filename]#/sbin/init.bak#, and finally [.filename]#/stand/"
"sysinstall#:"
msgstr ""

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/boot/chapter.adoc:1319
#, no-wrap
msgid ""
"sys/kern/init_main.c:\n"
"static char init_path[MAXPATHLEN] =\n"
"#ifdef\tINIT_PATH\n"
"    __XSTRING(INIT_PATH);\n"
"#else\n"
"    \"/sbin/init:/sbin/oinit:/sbin/init.bak:/stand/sysinstall\";\n"
"#endif\n"
msgstr ""
